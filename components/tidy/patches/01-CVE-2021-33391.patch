Original fix - https://github.com/htacg/tidy-html5/commit/efa61528aa500a1efbd2768121820742d3bb709b

Reworked patch that applies to 5.8.0 and the current version we ship

From 917eb83a2f0e6e1020ef80e97647d9fa6a47ac5e Mon Sep 17 00:00:00 2001
From: SeanDougherty <sdougherty@microsoft.com>
Date: Mon, 1 May 2023 21:49:06 -0700
Subject: [PATCH] Fix: backport patch for CVE-2021-33391 for tidy (#5432)

* Fix: patch CVE-2021-33391 for tidy

Co-authored-by: Christopher Co <35273088+christopherco@users.noreply.github.com>

---------
--- a/src/gdoc.c	2023-06-28 07:34:18.486534918 -0700
+++ b/src/gdoc.c	2023-06-28 07:36:07.291085535 -0700
@@ -96,11 +96,12 @@
 
 static void CleanNode( TidyDocImpl* doc, Node *node )
 {
+    Stack *stack = TY_(newStack)(doc, 16);
     Node *child, *next;
 
-    if (node->content)
+    if ( (child = node->content) )
     {
-        for (child = node->content; child != NULL; child = next)
+        while (child)
         {
             next = child->next;
 
@@ -126,11 +127,16 @@
                     if (child->attributes)
                         TY_(DropAttrByName)( doc, child, "class" );
 
-                    CleanNode(doc, child);
+                    TY_(push)(stack,next);
+		    child = child->content;
+		    continue;
                 }
             }
+	    child = next ? next : TY_(pop)(stack);
         }
     }
+    TY_(freeStack)(stack);
+    TidyFree(doc->allocator, stack);
 }
 
 /* insert meta element to force browser to recognize doc as UTF8 */
--- a/src/lexer.c	2023-06-28 07:36:23.283257490 -0700
+++ b/src/lexer.c	2023-06-28 07:39:26.937021211 -0700
@@ -892,15 +892,6 @@
     return 0;
 }
 
-/*
-   node->type is one of these:
-
-    #define TextNode    1
-    #define StartTag    2
-    #define EndTag      3
-    #define StartEndTag 4
-*/
-
 Lexer* TY_(NewLexer)( TidyDocImpl* doc )
 {
     Lexer* lexer = (Lexer*) TidyDocAlloc( doc, sizeof(Lexer) );
@@ -1551,13 +1542,7 @@
 #if !defined(NDEBUG) && defined(_MSC_VER) && defined(DEBUG_ALLOCATION)
     if (node) SPRTF("Free node %p\n", node );
 #endif
-    /* this is no good ;=((
-    if (node && doc && doc->lexer) {
-        if (node == doc->lexer->token) {
-            doc->lexer->token = NULL; // TY_(NewNode)( doc->lexer->allocator, doc->lexer );
-        }
-    }
-      ----------------- */
+
     while ( node )
     {
         Node* next = node->next;
@@ -4438,11 +4423,98 @@
     return NULL;
 }
 
-/*
- * local variables:
- * mode: c
- * indent-tabs-mode: nil
- * c-basic-offset: 4
- * eval: (c-set-offset 'substatement-open 0)
- * end:
+/****************************************************************************//*
+ ** MARK: - Node Stack
+ ***************************************************************************/
+
+
+/**
+ * Create a new stack with a given starting capacity. If memory allocation
+ * fails, then the allocator will panic the program automatically.
  */
+Stack* TY_(newStack)(TidyDocImpl *doc, uint capacity)
+{
+    Stack *stack = (Stack *)TidyAlloc(doc->allocator, sizeof(Stack));
+    stack->top = -1;
+    stack->capacity = capacity;
+    stack->firstNode = (Node **)TidyAlloc(doc->allocator, stack->capacity * sizeof(Node**));
+    stack->allocator = doc->allocator;
+    return stack;
+}
+/**
+ *  Increase the stack size. This will be called automatically when the
+ *  current stack is full. If memory allocation fails, then the allocator
+ *  will panic the program automatically.
+ */
+void TY_(growStack)(Stack *stack)
+{
+    uint new_capacity = stack->capacity * 2;
+
+    Node **firstNode = (Node **)TidyAlloc(stack->allocator, new_capacity);
+
+    memcpy( firstNode, stack->firstNode, sizeof(Node**) * (stack->top + 1) );
+    TidyFree(stack->allocator, stack->firstNode);
+
+    stack->firstNode = firstNode;
+    stack->capacity = new_capacity;
+}
+
+
+/**
+ * Stack is full when top is equal to the last index.
+ */
+Bool TY_(stackFull)(Stack *stack)
+{
+    return stack->top == stack->capacity - 1;
+}
+
+
+/**
+ * Stack is empty when top is equal to -1
+ */
+Bool TY_(stackEmpty)(Stack *stack)
+{
+    return stack->top == -1;
+}
+
+/**
+ * Push an item to the stack.
+ */
+void TY_(push)(Stack *stack, Node *node)
+{
+    if (TY_(stackFull)(stack))
+        TY_(growStack)(stack);
+
+    if (node)
+        stack->firstNode[++stack->top] = node;
+}
+
+
+/**
+ * Pop an item from the stack.
+ */
+Node* TY_(pop)(Stack *stack)
+{
+    return TY_(stackEmpty)(stack) ? NULL : stack->firstNode[stack->top--];
+}
+
+
+/**
+ * Peek at the stack.
+ */
+Node* TY_(peek)(Stack *stack)
+{
+    return TY_(stackEmpty)(stack) ? NULL : stack->firstNode[stack->top--];
+}
+
+/**
+ *  Frees the stack when done.
+ */
+void TY_(freeStack)(Stack *stack)
+{
+    TidyFree( stack->allocator, stack->firstNode );
+    stack->top = -1;
+    stack->capacity = 0;
+    stack->firstNode = NULL;
+    stack->allocator = NULL;
+}
--- a/src/lexer.h	2023-06-28 07:39:46.062623976 -0700
+++ b/src/lexer.h	2023-06-28 07:54:47.259010201 -0700
@@ -481,6 +481,7 @@
 /* void AddStringLiteralLen( Lexer* lexer, ctmbstr str, int len ); */
 
 /* find element */
+void TY_(AddStringLiteral)( Lexer* lexer, ctmbstr str );
 Node* TY_(FindDocType)( TidyDocImpl* doc );
 Node* TY_(FindHTML)( TidyDocImpl* doc );
 Node* TY_(FindHEAD)( TidyDocImpl* doc );
@@ -612,6 +613,78 @@
 Bool TY_(SwitchInline)( TidyDocImpl* doc, Node* element, Node* node );
 Bool TY_(InlineDup1)( TidyDocImpl* doc, Node* node, Node* element );
 
+/** @}
+ *  @name Generic stack of nodes.
+ *  @{
+ */
+ 
+
+/**
+ * This typedef represents a stack of addresses to nodes. Tidy uses these to
+ * try to limit recursion by pushing nodes to a stack when possible instead
+ * of recursing.
+ */
+typedef struct _Stack {
+    int top;                        /**< Current top position. */
+    unsigned capacity;              /**< Current capacity. Can be expanded. */
+    Node **firstNode;               /** A pointer to the first pointer to a Node in an array of node addresses. */
+    TidyAllocator* allocator;       /**< Tidy's allocator, used at instantiation and expanding. */
+} Stack;
+
+
+/**
+ * Create a new stack with a given starting capacity. If memory allocation
+ * fails, then the allocator will panic the program automatically.
+ */
+Stack* TY_(newStack)(TidyDocImpl *doc, uint capacity);
+
+
+/**
+ *  Increase the stack size. This will be called automatically when the
+ *  current stack is full. If memory allocation fails, then the allocator
+ *  will panic the program automatically.
+ */
+void TY_(growStack)(Stack *stack);
+
+
+/*
+ * Stack is full when top is equal to the last index.
+ */
+Bool TY_(stackFull)(Stack *stack);
+
+
+/*
+ * Stack is empty when top is equal to -1
+ */
+Bool TY_(stackEmpty)(Stack *stack);
+
+
+/**
+ * Push an item to the stack.
+ */
+void TY_(push)(Stack *stack, Node *node);
+
+
+/**
+ * Pop an item from the stack.
+ */
+Node* TY_(pop)(Stack *stack);
+
+
+/**
+ * Peek at the stack.
+ */
+Node* TY_(peek)(Stack *stack);
+
+/**
+ *  Frees the stack when done.
+ */
+void TY_(freeStack)(Stack *stack);
+
+
+/** @}
+ */
+
 #ifdef __cplusplus
 }
 #endif
