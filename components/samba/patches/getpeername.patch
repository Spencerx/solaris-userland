This patches fixes:

set_remote_addresses: tsocket_address_bsd_from_sockaddr failed: NT_STATUS_ACCESS_DENIED

The behavior on Linux is that getpeername() and getsockname() on UNIX socket
returns address length >= 2 in all cases and fills in sun_family = AF_UNIX.  In
Solaris, this is different and sometimes (see corresponding man pages) the call
succeeds (return value 0), but address length is returned as 0. Once this is
fixed, the patch can be removed. The patch will not be sent to community.

diff -ru samba-4.19.2.orig/source3/winbindd/winbindd_dual_ndr.c samba-4.19.2.new/source3/winbindd/winbindd_dual_ndr.c
--- samba-4.19.2.orig/source3/winbindd/winbindd_dual_ndr.c	2023-07-18 10:14:55.002094300 +0200
+++ samba-4.19.2.new/source3/winbindd/winbindd_dual_ndr.c	2023-11-01 14:14:54.961919810 +0100
@@ -469,12 +469,21 @@
 		return status;
 	}
 
-	ret = tsocket_address_bsd_from_sockaddr(conn, sar, sa_len, &remote);
-	if (ret != 0) {
-		status = map_nt_error_from_unix(ret);
-		DBG_ERR("tsocket_address_bsd_from_sockaddr failed: %s",
-			nt_errstr(status));
-		return status;
+	/*
+	 * The function getpeername() on Solaris returns 0 in 'sa_len' if the
+	 * argument refers to UNIX socket with no peer. That's allowed in
+	 * standard. In such case just skip tsocket_address_bsd_from_sockaddr()
+	 * to avoid failure and leave the remote address empty / NULL.
+	 */
+	if (sa_len > 0) {
+		ret = tsocket_address_bsd_from_sockaddr(conn, sar, sa_len,
+		    &remote);
+		if (ret != 0) {
+			status = map_nt_error_from_unix(ret);
+			DBG_ERR("tsocket_address_bsd_from_sockaddr failed: %s",
+				nt_errstr(status));
+			return status;
+		}
 	}
 
 	ZERO_STRUCT(st);
@@ -485,12 +494,21 @@
 		return status;
 	}
 
-	ret = tsocket_address_bsd_from_sockaddr(conn, sar, sa_len, &local);
-	if (ret != 0) {
-		status = map_nt_error_from_unix(ret);
-		DBG_ERR("tsocket_address_bsd_from_sockaddr failed: %s",
-			nt_errstr(status));
-		return status;
+	/*
+	 * The function getsockname() on Solaris returns 0 in 'sa_len' if the
+	 * argument refers to anonymous UNIX socket. That's allowed in
+	 * standard. In such case just skip tsocket_address_bsd_from_sockaddr()
+	 * to avoid failure and leave the remote address empty / NULL.
+	 */
+	if (sa_len > 0) {
+		ret = tsocket_address_bsd_from_sockaddr(conn, sar, sa_len,
+		    &local);
+		if (ret != 0) {
+			status = map_nt_error_from_unix(ret);
+			DBG_ERR("tsocket_address_bsd_from_sockaddr failed: %s",
+				nt_errstr(status));
+			return status;
+		}
 	}
 
 	conn->local_address = talloc_move(conn, &local);
