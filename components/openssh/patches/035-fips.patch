#
# Limit ciphers and MACs in algorithm negotiation proposal,
# when underlying libcrypto is FIPS capable.
#
# This patch is unlikely to be accepted upstream.
#
--- openssh-9.4p1/Makefile.in
+++ openssh-9.4p1/Makefile.in
@@ -213,7 +213,7 @@ sshd$(EXEEXT): libssh.a	$(LIBCOMPAT) $(S
 	$(LD) -o $@ $(SSHDOBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(SSHDLIBS) $(LIBS) $(GSSLIBS) $(K5LIBS) $(CHANNELLIBS)
 
 scp$(EXEEXT): $(LIBCOMPAT) libssh.a $(SCP_OBJS)
-	$(LD) -o $@ $(SCP_OBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
+	$(LD) -o $@ $(SCP_OBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(CHANNELLIBS)
 
 ssh-add$(EXEEXT): $(LIBCOMPAT) libssh.a $(SSHADD_OBJS)
 	$(LD) -o $@ $(SSHADD_OBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(CHANNELLIBS)
@@ -237,10 +237,10 @@ ssh-keyscan$(EXEEXT): $(LIBCOMPAT) libss
 	$(LD) -o $@ $(SSHKEYSCAN_OBJS) $(LDFLAGS) -lssh -lopenbsd-compat -lssh $(LIBS) $(CHANNELLIBS)
 
 sftp-server$(EXEEXT): $(LIBCOMPAT) libssh.a $(SFTPSERVER_OBJS)
-	$(LD) -o $@ $(SFTPSERVER_OBJS) $(LDFLAGS) -lssh -lopenbsd-compat -lssh $(LIBS)
+	$(LD) -o $@ $(SFTPSERVER_OBJS) $(LDFLAGS) -lssh -lopenbsd-compat -lssh $(LIBS) $(CHANNELLIBS)
 
 sftp$(EXEEXT): $(LIBCOMPAT) libssh.a $(SFTP_OBJS)
-	$(LD) -o $@ $(SFTP_OBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(LIBEDIT)
+	$(LD) -o $@ $(SFTP_OBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(CHANNELLIBS) $(LIBEDIT)
 
 # test driver for the loginrec code - not built by default
 logintest: logintest.o $(LIBCOMPAT) libssh.a loginrec.o
--- openssh-9.4p1/cipher.c
+++ openssh-9.4p1/cipher.c
@@ -83,7 +83,39 @@ void	*ignored;
 #endif
 };
 
+#ifdef ENABLE_OPENSSL_FIPS
+/* in FIPS mode limit ciphers to FIPS compliant only */
+#define	ciphers (ssh_FIPS_mode() ? ciphers_fips : ciphers_dflt)
+
+static const struct sshcipher ciphers_fips[] = {
+#ifdef WITH_OPENSSL
+#ifndef OPENSSL_NO_DES
+	{ "3des-cbc",		8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },
+#endif
+	{ "aes128-cbc",		16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },
+	{ "aes192-cbc",		16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },
+	{ "aes256-cbc",		16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },
+	{ "aes128-ctr",		16, 16, 0, 0, 0, EVP_aes_128_ctr },
+	{ "aes192-ctr",		16, 24, 0, 0, 0, EVP_aes_192_ctr },
+	{ "aes256-ctr",		16, 32, 0, 0, 0, EVP_aes_256_ctr },
+	{ "aes128-gcm@openssh.com",
+				16, 16, 12, 16, 0, EVP_aes_128_gcm },
+	{ "aes256-gcm@openssh.com",
+				16, 32, 12, 16, 0, EVP_aes_256_gcm },
+#else
+	{ "aes128-ctr",		16, 16, 0, 0, CFLAG_AESCTR, NULL },
+	{ "aes192-ctr",		16, 24, 0, 0, CFLAG_AESCTR, NULL },
+	{ "aes256-ctr",		16, 32, 0, 0, CFLAG_AESCTR, NULL },
+#endif
+	{ "none",		8, 0, 0, 0, CFLAG_NONE, NULL },
+
+	{ NULL,			0, 0, 0, 0, 0, NULL }
+};
+
+static const struct sshcipher ciphers_dflt[] = {
+#else /* ENABLE_OPENSSL_FIPS */
 static const struct sshcipher ciphers[] = {
+#endif /* ENABLE_OPENSSL_FIPS */
 #ifdef WITH_OPENSSL
 #ifndef OPENSSL_NO_DES
 	{ "3des-cbc",		8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },
--- openssh-9.4p1/digest-openssl.c
+++ openssh-9.4p1/digest-openssl.c
@@ -31,6 +31,7 @@ #include "openbsd-compat/openssl-compat.
 #include "sshbuf.h"
 #include "digest.h"
 #include "ssherr.h"
+#include "misc.h"
 
 #ifndef HAVE_EVP_SHA256
 # define EVP_sha256 NULL
@@ -54,8 +55,21 @@ size_t digest_len;
 	const EVP_MD *(*mdfunc)(void);
 };
 
+#ifdef ENABLE_OPENSSL_FIPS
 /* NB. Indexed directly by algorithm number */
+const struct ssh_digest digests_fips[] = {
+	{ SSH_DIGEST_MD5,	"",	 	16,	NULL },
+	{ SSH_DIGEST_SHA1,	"SHA1",	 	20,	EVP_sha1 },
+	{ SSH_DIGEST_SHA256,	"SHA256", 	32,	EVP_sha256 },
+	{ SSH_DIGEST_SHA384,	"SHA384",	48,	EVP_sha384 },
+	{ SSH_DIGEST_SHA512,	"SHA512", 	64,	EVP_sha512 },
+	{ -1,			NULL,		0,	NULL },
+};
+/* NB. Indexed directly by algorithm number */
+const struct ssh_digest digests_dflt[] = {
+#else /* ENABLE_OPENSSL_FIPS */
 const struct ssh_digest digests[] = {
+#endif /* ENABLE_OPENSSL_FIPS */
 	{ SSH_DIGEST_MD5,	"MD5",		16,	EVP_md5 },
 	{ SSH_DIGEST_SHA1,	"SHA1",		20,	EVP_sha1 },
 	{ SSH_DIGEST_SHA256,	"SHA256",	32,	EVP_sha256 },
@@ -67,6 +81,9 @@ };
 static const struct ssh_digest *
 ssh_digest_by_alg(int alg)
 {
+#ifdef ENABLE_OPENSSL_FIPS
+	struct ssh_digest *digests = ssh_FIPS_mode() ? digests_fips : digests_dflt;
+#endif
 	if (alg < 0 || alg >= SSH_DIGEST_MAX)
 		return NULL;
 	if (digests[alg].id != alg) /* sanity */
@@ -79,6 +96,9 @@ }
 int
 ssh_digest_alg_by_name(const char *name)
 {
+#ifdef ENABLE_OPENSSL_FIPS
+	struct ssh_digest *digests = ssh_FIPS_mode() ? digests_fips : digests_dflt;
+#endif
 	int alg;
 
 	for (alg = 0; digests[alg].id != -1; alg++) {
--- openssh-9.4p1/kex.c
+++ openssh-9.4p1/kex.c
@@ -91,7 +91,43 @@ u_int type;
 	int ec_nid;
 	int hash_alg;
 };
+
+#ifdef ENABLE_OPENSSL_FIPS
+/* in FIPS mode limit kexalgs to FIPS compliant only */
+#define        kexalgs (ssh_FIPS_mode() ? kexalgs_fips : kexalgs_dflt)
+static const struct kexalg kexalgs_fips[] = {
+#ifdef WITH_OPENSSL
+	{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },
+	{ KEX_DH14_SHA1, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },
+	{ KEX_DH14_SHA256, KEX_DH_GRP14_SHA256, 0, SSH_DIGEST_SHA256 },
+	{ KEX_DH16_SHA512, KEX_DH_GRP16_SHA512, 0, SSH_DIGEST_SHA512 },
+	{ KEX_DH18_SHA512, KEX_DH_GRP18_SHA512, 0, SSH_DIGEST_SHA512 },
+	{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, SSH_DIGEST_SHA1 },
+#ifdef HAVE_EVP_SHA256
+	{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, SSH_DIGEST_SHA256 },
+#endif /* HAVE_EVP_SHA256 */
+#ifdef OPENSSL_HAS_ECC
+	{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2,
+	    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },
+	{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1,
+	    SSH_DIGEST_SHA384 },
+# ifdef OPENSSL_HAS_NISTP521
+	{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1,
+	    SSH_DIGEST_SHA512 },
+# endif /* OPENSSL_HAS_NISTP521 */
+#endif /* OPENSSL_HAS_ECC */
+#endif /* WITH_OPENSSL */
+#ifdef GSSAPI
+	{ KEX_GSS_GEX_SHA1_ID, KEX_GSS_GEX_SHA1, 0, SSH_DIGEST_SHA1 },
+	{ KEX_GSS_GRP1_SHA1_ID, KEX_GSS_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },
+	{ KEX_GSS_GRP14_SHA1_ID, KEX_GSS_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },
+#endif
+	{ NULL, -1, -1, -1},
+};
+static const struct kexalg kexalgs_dflt[] = {
+#else
 static const struct kexalg kexalgs[] = {
+#endif 
 #ifdef WITH_OPENSSL
 	{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },
 	{ KEX_DH14_SHA1, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },
@@ -1348,10 +1384,18 @@ /* Prepare and send our banner */
 	sshbuf_reset(our_version);
 	if (version_addendum != NULL && *version_addendum == '\0')
 		version_addendum = NULL;
+#ifdef ENABLE_OPENSSL_FIPS
+	if ((r = sshbuf_putf(our_version, "SSH-%d.%d-%.100s%s%s%s\r\n",
+	    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION,
+	    ssh_FIPS_mode() ? " FIPS" : "",
+	    version_addendum == NULL ? "" : " ",
+	    version_addendum == NULL ? "" : version_addendum)) != 0) {
+#else
 	if ((r = sshbuf_putf(our_version, "SSH-%d.%d-%.100s%s%s\r\n",
 	    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION,
 	    version_addendum == NULL ? "" : " ",
 	    version_addendum == NULL ? "" : version_addendum)) != 0) {
+#endif
 		oerrno = errno;
 		error_fr(r, "sshbuf_putf");
 		goto out;
--- openssh-9.4p1/mac.c
+++ openssh-9.4p1/mac.c
@@ -55,8 +55,33 @@ int		key_len;	/* just for UMAC */
 	int		len;		/* just for UMAC */
 	int		etm;		/* Encrypt-then-MAC */
 };
+#ifdef ENABLE_OPENSSL_FIPS
+/* in FIPS mode limit macs to FIPS compliant only */
+#define	macs (ssh_FIPS_mode() ? macs_fips : macs_dflt)
 
+static const struct macalg macs_fips[] = {
+	/* Encrypt-and-MAC (encrypt-and-authenticate) variants */
+	{ "hmac-sha1",				SSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 0 },
+	{ "hmac-sha1-96",			SSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 0 },
+#ifdef HAVE_EVP_SHA256
+	{ "hmac-sha2-256",			SSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 0 },
+	{ "hmac-sha2-512",			SSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 0 },
+#endif
+	/* Encrypt-then-MAC variants */
+	{ "hmac-sha1-etm@openssh.com",		SSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 1 },
+	{ "hmac-sha1-96-etm@openssh.com",	SSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 1 },
+#ifdef HAVE_EVP_SHA256
+	{ "hmac-sha2-256-etm@openssh.com",	SSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 1 },
+	{ "hmac-sha2-512-etm@openssh.com",	SSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 1 },
+#endif
+
+	{ NULL,					0, 0, 0, 0, 0, 0 }
+};
+
+static const struct macalg macs_dflt[] = {
+#else /* ENABLE_OPENSSL_FIPS */
 static const struct macalg macs[] = {
+#endif /* ENABLE_OPENSSL_FIPS */
 	/* Encrypt-and-MAC (encrypt-and-authenticate) variants */
 	{ "hmac-sha1",				SSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 0 },
 	{ "hmac-sha1-96",			SSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 0 },
--- openssh-9.4p1/misc.c
+++ openssh-9.4p1/misc.c
@@ -49,6 +49,7 @@ #include <stdlib.h>
 #include <string.h>
 #include <time.h>
 #include <unistd.h>
+#include <dlfcn.h>
 
 #include <netinet/in.h>
 #include <netinet/in_systm.h>
@@ -56,6 +57,10 @@ #include <netinet/ip.h>
 #include <netinet/tcp.h>
 #include <arpa/inet.h>
 
+#include <openssl/crypto.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -107,6 +112,28 @@ s[i] = '\0';
 	}
 }
 
+#ifdef ENABLE_OPENSSL_FIPS
+/* is OpenSSL FIPS mode set? */
+int
+ssh_FIPS_mode()
+{
+	return (EVP_default_properties_is_fips_enabled(NULL));
+}
+
+/*
+ * Check and display FIPS mode status. 
+ */
+void 
+ssh_FIPS_check_status()
+{
+	if (ssh_FIPS_mode()) {
+		debug("Running in FIPS mode.");
+	} else {
+		debug("Running in non-FIPS mode.");
+	}
+}
+#endif
+
 /* set/unset filedescriptor to non-blocking */
 int
 set_nonblock(int fd)
--- openssh-9.4p1/misc.h
+++ openssh-9.4p1/misc.h
@@ -49,6 +49,10 @@ void	 rtrim(char *);
 void	skip_space(char **);
 char	*strdelim(char **);
 char	*strdelimw(char **);
+#ifdef ENABLE_OPENSSL_FIPS
+int	 ssh_FIPS_mode();
+void     ssh_FIPS_check_status();
+#endif
 int	 set_nonblock(int);
 int	 unset_nonblock(int);
 void	 set_nodelay(int);
--- openssh-9.4p1/myproposal.h
+++ openssh-9.4p1/myproposal.h
@@ -24,7 +24,7 @@ * (INCLUDING NEGLIGENCE OR OTHERWISE) AR
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#define KEX_SERVER_KEX	\
+#define KEX_SERVER_KEX_DFLT \
 	"sntrup761x25519-sha512@openssh.com," \
 	"curve25519-sha256," \
 	"curve25519-sha256@libssh.org," \
@@ -36,9 +36,24 @@ "diffie-hellman-group16-sha512," \
 	"diffie-hellman-group18-sha512," \
 	"diffie-hellman-group14-sha256"
 
-#define KEX_CLIENT_KEX KEX_SERVER_KEX
+#define KEX_CLIENT_KEX_DFLT KEX_SERVER_KEX_DFLT
 
-#define	KEX_DEFAULT_PK_ALG	\
+#define KEX_COMMON_KEX_FIPS \
+	"ecdh-sha2-nistp256," \
+	"ecdh-sha2-nistp384," \
+	"ecdh-sha2-nistp521," \
+	"diffie-hellman-group-exchange-sha256," \
+	"diffie-hellman-group16-sha512," \
+	"diffie-hellman-group18-sha512,"
+
+#define KEX_SERVER_KEX_FIPS KEX_COMMON_KEX_FIPS \
+	"diffie-hellman-group14-sha1" \
+
+#define KEX_CLIENT_KEX_FIPS KEX_COMMON_KEX_FIPS \
+	"diffie-hellman-group-exchange-sha1," \
+	"diffie-hellman-group14-sha1"
+
+#define	KEX_DEFAULT_PK_ALG_DFLT	\
 	"ssh-ed25519-cert-v01@openssh.com," \
 	"ecdsa-sha2-nistp256-cert-v01@openssh.com," \
 	"ecdsa-sha2-nistp384-cert-v01@openssh.com," \
@@ -56,14 +71,36 @@ "sk-ecdsa-sha2-nistp256@openssh.com," \
 	"rsa-sha2-512," \
 	"rsa-sha2-256"
 
-#define	KEX_SERVER_ENCRYPT \
+#define	KEX_DEFAULT_PK_ALG_FIPS \
+	"ecdsa-sha2-nistp256-cert-v01@openssh.com," \
+	"ecdsa-sha2-nistp384-cert-v01@openssh.com," \
+	"ecdsa-sha2-nistp521-cert-v01@openssh.com," \
+	"sk-ecdsa-sha2-nistp256-cert-v01@openssh.com," \
+	"rsa-sha2-512-cert-v01@openssh.com," \
+	"rsa-sha2-256-cert-v01@openssh.com," \
+	"ecdsa-sha2-nistp256," \
+	"ecdsa-sha2-nistp384," \
+	"ecdsa-sha2-nistp521," \
+	"sk-ecdsa-sha2-nistp256@openssh.com," \
+	"rsa-sha2-512," \
+	"rsa-sha2-256"
+
+#define KEX_SERVER_ENCRYPT_DFLT \
 	"chacha20-poly1305@openssh.com," \
 	"aes128-ctr,aes192-ctr,aes256-ctr," \
 	"aes128-gcm@openssh.com,aes256-gcm@openssh.com"
 
-#define KEX_CLIENT_ENCRYPT KEX_SERVER_ENCRYPT
+#define KEX_CLIENT_ENCRYPT_DFLT KEX_SERVER_ENCRYPT_DFLT "," \
+	"aes128-cbc,aes192-cbc,aes256-cbc"
 
-#define	KEX_SERVER_MAC \
+#define KEX_SERVER_ENCRYPT_FIPS \
+	"aes128-ctr,aes192-ctr,aes256-ctr," \
+	"aes128-gcm@openssh.com,aes256-gcm@openssh.com"
+
+#define KEX_CLIENT_ENCRYPT_FIPS KEX_SERVER_ENCRYPT_FIPS "," \
+	"aes128-cbc,aes192-cbc,aes256-cbc"
+
+#define KEX_SERVER_MAC_DFLT \
 	"umac-64-etm@openssh.com," \
 	"umac-128-etm@openssh.com," \
 	"hmac-sha2-256-etm@openssh.com," \
@@ -75,7 +112,42 @@ "hmac-sha2-256," \
 	"hmac-sha2-512," \
 	"hmac-sha1"
 
-#define KEX_CLIENT_MAC KEX_SERVER_MAC
+#define KEX_CLIENT_MAC_DFLT KEX_SERVER_MAC_DFLT
+
+#define KEX_SERVER_MAC_FIPS \
+	"hmac-sha2-256-etm@openssh.com," \
+	"hmac-sha2-512-etm@openssh.com," \
+	"hmac-sha1-etm@openssh.com," \
+	"hmac-sha2-256," \
+	"hmac-sha2-512," \
+	"hmac-sha1"
+
+#define KEX_CLIENT_MAC_FIPS KEX_SERVER_MAC_FIPS
+
+#ifdef ENABLE_OPENSSL_FIPS
+ #define KEX_SERVER_KEX \
+     (ssh_FIPS_mode() ? (KEX_SERVER_KEX_FIPS) : (KEX_SERVER_KEX_DFLT) )
+ #define KEX_CLIENT_KEX \
+     (ssh_FIPS_mode() ? (KEX_CLIENT_KEX_FIPS) : (KEX_CLIENT_KEX_DFLT) )
+ #define KEX_DEFAULT_PK_ALG \
+     (ssh_FIPS_mode() ? (KEX_DEFAULT_PK_ALG_FIPS) : (KEX_DEFAULT_PK_ALG_DFLT) )
+ #define KEX_SERVER_ENCRYPT \
+    (ssh_FIPS_mode() ? (KEX_SERVER_ENCRYPT_FIPS) : (KEX_SERVER_ENCRYPT_DFLT))
+ #define KEX_CLIENT_ENCRYPT \
+    (ssh_FIPS_mode() ? (KEX_CLIENT_ENCRYPT_FIPS) : (KEX_CLIENT_ENCRYPT_DFLT))
+ #define KEX_SERVER_MAC \
+    (ssh_FIPS_mode() ? (KEX_SERVER_MAC_FIPS) : (KEX_SERVER_MAC_DFLT) )
+ #define KEX_CLIENT_MAC \
+    (ssh_FIPS_mode() ? (KEX_CLIENT_MAC_FIPS) : (KEX_CLIENT_MAC_DFLT) )
+#else /* ENABLE_OPENSSL_FIPS */
+ #define KEX_SERVER_KEX KEX_SERVER_KEX_DFLT
+ #define KEX_CLIENT_KEX KEX_CLIENT_KEX_DFLT
+ #define KEX_DEFAULT_PK_ALG KEX_DEFAULT_PK_ALG_DFLT
+ #define KEX_SERVER_ENCRYPT KEX_SERVER_ENCRYPT_DFLT
+ #define KEX_CLIENT_ENCRYPT KEX_CLIENT_ENCRYPT_DFLT
+ #define KEX_SERVER_MAC KEX_SERVER_MAC_DFLT
+ #define KEX_CLIENT_MAC KEX_CLIENT_MAC_DFLT
+#endif /* ENABLE_OPENSSL_FIPS */
 
 /* Not a KEX value, but here so all the algorithm defaults are together */
 #define	SSH_ALLOWED_CA_SIGALGS	\
--- openssh-9.4p1/ssh-add.1
+++ openssh-9.4p1/ssh-add.1
@@ -128,6 +128,8 @@ and
 .Dq sha256 .
 The default is
 .Dq sha256 .
+If OpenSSL is running in FIPS-140 mode, the only supported option is
+.Dq sha256 .
 .It Fl e Ar pkcs11
 Remove keys provided by the PKCS#11 shared library
 .Ar pkcs11 .
--- openssh-9.4p1/ssh-agent.1
+++ openssh-9.4p1/ssh-agent.1
@@ -100,6 +100,8 @@ and
 .Dq sha256 .
 The default is
 .Dq sha256 .
+If OpenSSL is running in FIPS-140 mode, the only supported option is
+.Dq sha256 .
 .It Fl k
 Kill the current agent (given by the
 .Ev SSH_AGENT_PID
--- openssh-9.4p1/ssh-agent.c
+++ openssh-9.4p1/ssh-agent.c
@@ -2201,6 +2201,9 @@ format = c_flag ? "setenv %s %s;\n" : "%
 		printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
 		    SSH_AUTHSOCKET_ENV_NAME);
 		printf("echo Agent pid %ld;\n", (long)parent_pid);
+#ifdef ENABLE_OPENSSL_FIPS
+		ssh_FIPS_check_status();
+#endif
 		fflush(stdout);
 		goto skip;
 	}
--- openssh-9.4p1/ssh-keygen.1
+++ openssh-9.4p1/ssh-keygen.1
@@ -282,6 +282,8 @@ default path for the resulting host key
 This is used by
 .Pa /etc/rc
 to generate new host keys.
+If OpenSSL is running in FIPS-140 mode, only rsa, dsa and ecdsa host
+keys are generated.
 .It Fl a Ar rounds
 When saving a private key, this option specifies the number of KDF
 (key derivation function, currently
@@ -328,6 +330,8 @@ and
 .Dq sha256 .
 The default is
 .Dq sha256 .
+If OpenSSL is running in FIPS-140 mode, the only supported option is
+.Dq sha256 .
 .It Fl e
 This option will read a private or public OpenSSH key file and
 print to stdout a public key in one of the formats specified by the
--- openssh-9.4p1/ssh-keygen.c
+++ openssh-9.4p1/ssh-keygen.c
@@ -1048,7 +1048,12 @@ struct {
 		char *key_type;
 		char *key_type_display;
 		char *path;
-	} key_types[] = {
+	}
+#ifndef ENABLE_OPENSSL_FIPS
+	key_types[] = {
+#else /* ENABLE_OPENSSL_FIPS */
+	key_types_dflt[] = {
+#endif /* ENABLE_OPENSSL_FIPS */
 #ifdef WITH_OPENSSL
 		{ "rsa", "RSA" ,_PATH_HOST_RSA_KEY_FILE },
 #ifdef OPENSSL_HAS_ECC
@@ -1059,8 +1064,21 @@ { "ed25519", "ED25519",_PATH_HOST_ED2551
 #ifdef WITH_XMSS
 		{ "xmss", "XMSS",_PATH_HOST_XMSS_KEY_FILE },
 #endif /* WITH_XMSS */
-		{ NULL, NULL, NULL }
-	};
+#ifndef ENABLE_OPENSSL_FIPS
+		{ NULL, NULL, NULL }};
+#else /* ENABLE_OPENSSL_FIPS */
+		{ NULL, NULL, NULL }},
+	key_types_fips[] = {
+#ifdef WITH_OPENSSL
+		{ "rsa", "RSA" ,_PATH_HOST_RSA_KEY_FILE },
+		{ "dsa", "DSA", _PATH_HOST_DSA_KEY_FILE },
+#ifdef OPENSSL_HAS_ECC
+		{ "ecdsa", "ECDSA",_PATH_HOST_ECDSA_KEY_FILE },
+#endif /* OPENSSL_HAS_ECC */
+#endif /* WITH_OPENSSL */
+		{ NULL, NULL, NULL }},
+	*key_types = ssh_FIPS_mode() ? key_types_fips : key_types_dflt;
+#endif /* ENABLE_OPENSSL_FIPS */
 
 	u_int32_t bits = 0;
 	int first = 0;
@@ -3364,6 +3382,10 @@ seed_rng();
 
 	log_init(argv[0], SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_USER, 1);
 
+#ifdef ENABLE_OPENSSL_FIPS
+	ssh_FIPS_check_status();
+#endif
+
 	msetlocale();
 
 	/* we need this for the home * directory.  */
--- openssh-9.4p1/ssh-keysign.c
+++ openssh-9.4p1/ssh-keysign.c
@@ -234,6 +234,12 @@ }
 	if (found == 0)
 		fatal("could not open any host key");
 
+#ifdef ENABLE_OPENSSL_FIPS
+#ifdef DEBUG_SSH_KEYSIGN
+	ssh_FIPS_check_status();
+#endif
+#endif
+
 	found = 0;
 	for (i = 0; i < NUM_KEYTYPES; i++) {
 		keys[i] = NULL;
--- openssh-9.4p1/ssh.1
+++ openssh-9.4p1/ssh.1
@@ -102,6 +102,9 @@ or it may have additional arguments.
 If supplied, the arguments will be appended to the command, separated by
 spaces, before it is sent to the server to be executed.
 .Pp
+If ssh links with FIPS-capable OpenSSL, ssh runs in FIPS-140 mode.
+In FIPS-140 mode non-FIPS approved ciphers, MACs and digests are disabled.
+.Pp
 The options are as follows:
 .Pp
 .Bl -tag -width Ds -compact
--- openssh-9.4p1/ssh.c
+++ openssh-9.4p1/ssh.c
@@ -1173,6 +1173,10 @@ !use_syslog);
 	if (debug_flag)
 		logit("%s, %s", SSH_RELEASE, SSH_OPENSSL_VERSION);
 
+#ifdef ENABLE_OPENSSL_FIPS
+	ssh_FIPS_check_status();
+#endif
+
 	/* Parse the configuration files */
 	process_config_files(options.host_arg, pw, 0, &want_final_pass);
 	if (want_final_pass)
--- openssh-9.4p1/ssh_api.c
+++ openssh-9.4p1/ssh_api.c
@@ -88,6 +88,9 @@ static int called;
 	int r;
 
 	if (!called) {
+#ifdef ENABLE_OPENSSL_FIPS
+		ssh_FIPS_check_status();
+#endif
 		seed_rng();
 		called = 1;
 	}
--- openssh-9.4p1/ssh_config.5
+++ openssh-9.4p1/ssh_config.5
@@ -508,6 +508,13 @@ aes128-ctr,aes192-ctr,aes256-ctr,
 aes128-gcm@openssh.com,aes256-gcm@openssh.com
 .Ed
 .Pp
+The following ciphers are FIPS-140 approved and are supported in FIPS-140 mode:
+.Bd -literal -offset indent
+aes128-ctr,aes192-ctr,aes256-ctr,
+aes128-gcm@openssh.com,aes256-gcm@openssh.com,
+aes128-cbc,3des-cbc,aes192-cbc,aes256-cbc
+.Ed
+.Pp
 The list of available ciphers may also be obtained using
 .Qq ssh -Q cipher .
 .It Cm ClearAllForwardings
@@ -772,6 +779,8 @@ .Fl f
 option) or
 .Cm no
 (the default).
+In FIPS-140 mode the only supported option is
+.Dq sha256 .
 .It Cm ForwardAgent
 Specifies whether the connection to the authentication agent (if any)
 will be forwarded to the remote machine.
@@ -881,6 +890,8 @@ Specifies whether key exchange based on
 GSSAPI key exchange the server need not have a host key.
 The default is
 .Cm no .
+.Pp
+GSSAPI key exchange is not available in FIPS-140 mode.
 .It Cm GSSAPIRenewalForcesRekey
 If set to
 .Cm yes
@@ -1409,6 +1420,16 @@ umac-64@openssh.com,umac-128@openssh.com
 hmac-sha2-256,hmac-sha2-512,hmac-sha1
 .Ed
 .Pp
+The following MACs are FIPS-140 approved and are supported in FIPS-140 mode:
+.Bd -literal -offset indent
+hmac-sha2-256-etm@openssh.com,
+hmac-sha2-512-etm@openssh.com,
+hmac-sha2-256,hmac-sha2-512,
+hmac-sha1-etm@openssh.com,
+hmac-sha1-96-etm@openssh.com
+hmac-sha1,hmac-sha1-96
+.Ed
+.Pp
 The list of available MAC algorithms may also be obtained using
 .Qq ssh -Q mac .
 .It Cm NoHostAuthenticationForLocalhost
@@ -1499,6 +1520,9 @@ .Bd -literal -offset indent
 publickey,gssapi-keyex,gssapi-with-mic,password,
 keyboard-interactive,hostbased
 .Ed
+.Pp
+.Cm gssapi-keyex
+is not available in FIPS-140 mode.
 .It Cm ProxyCommand
 Specifies the command to use to connect to the server.
 The command
--- openssh-9.4p1/sshconnect2.c
+++ openssh-9.4p1/sshconnect2.c
@@ -270,29 +270,36 @@ free(hkalgs);
 
 #if defined(GSSAPI) && defined(WITH_OPENSSL)
 	if (options.gss_keyex) {
-		/* Add the GSSAPI mechanisms currently supported on this
-		 * client to the key exchange algorithm proposal */
-		orig = myproposal[PROPOSAL_KEX_ALGS];
+		if (ssh_FIPS_mode()) {
+			logit("Disabling GSSAPIKeyExchange. Not available"
+			    " in FIPS mode");
+			options.gss_keyex = 0;
+		} else {
+			/* Add the GSSAPI mechanisms currently supported on this
+			 * client to the key exchange algorithm proposal */
+			orig = myproposal[PROPOSAL_KEX_ALGS];
 
-		if (options.gss_server_identity)
-			gss_host = xstrdup(options.gss_server_identity);
-		else if (options.gss_trust_dns)
-			gss_host = remote_hostname(ssh);
-		else
-			gss_host = xstrdup(host);
+			if (options.gss_server_identity)
+				gss_host = xstrdup(options.gss_server_identity);
+			else if (options.gss_trust_dns)
+				gss_host = remote_hostname(ssh);
+			else
+				gss_host = xstrdup(host);
 
-		gss = ssh_gssapi_client_mechanisms(gss_host,
-		    options.gss_client_identity, options.gss_kex_algorithms);
-		if (gss) {
-			debug("Offering GSSAPI proposal: %s", gss);
-			xasprintf(&myproposal[PROPOSAL_KEX_ALGS],
-			    "%s,%s", gss, orig);
+			gss = ssh_gssapi_client_mechanisms(gss_host,
+			    options.gss_client_identity,
+			    options.gss_kex_algorithms);
+			if (gss) {
+				debug("Offering GSSAPI proposal: %s", gss);
+				xasprintf(&myproposal[PROPOSAL_KEX_ALGS],
+				    "%s,%s", gss, orig);
 
-			/* If we've got GSSAPI algorithms, then we also support the
-			 * 'null' hostkey, as a last resort */
-			orig = myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS];
-			xasprintf(&myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS],
-			    "%s,null", orig);
+				/* If we've got GSSAPI algorithms, then we also
+				 * support the 'null' hostkey, as a last resort */
+				orig = myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS];
+				xasprintf(&myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS],
+				    "%s,null", orig);
+			}
 		}
 	}
 #endif
--- openssh-9.4p1/sshd.8
+++ openssh-9.4p1/sshd.8
@@ -83,6 +83,9 @@ .Dv SIGHUP ,
 by executing itself with the name and options it was started with, e.g.\&
 .Pa /usr/sbin/sshd .
 .Pp
+If sshd links with FIPS-capable OpenSSL, sshd runs in FIPS-140 mode.
+In FIPS-140 mode non-FIPS approved ciphers, MACs and digests are disabled.
+.Pp
 The options are as follows:
 .Bl -tag -width Ds
 .It Fl 4
--- openssh-9.4p1/sshd.c
+++ openssh-9.4p1/sshd.c
@@ -1729,6 +1729,10 @@ options.log_facility == SYSLOG_FACILITY_
 	    SYSLOG_FACILITY_AUTH : options.log_facility,
 	    log_stderr || !inetd_flag || debug_flag);
 
+#ifdef ENABLE_OPENSSL_FIPS
+	ssh_FIPS_check_status();
+#endif
+
 	/*
 	 * Unset KRB5CCNAME, otherwise the user's session may inherit it from
 	 * root's environment
@@ -2424,10 +2428,15 @@ */
 	if (strlen(myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS]) == 0)
 		orig = NULL;
 
-	if (options.gss_keyex)
-		gss = ssh_gssapi_server_mechanisms();
-	else
-		gss = NULL;
+	if (options.gss_keyex) {
+		if (ssh_FIPS_mode()) {
+			logit("Disabling GSSAPIKeyExchange. Not available"
+			    " in FIPS mode");
+			options.gss_keyex = 0;
+		} else {
+			gss = ssh_gssapi_server_mechanisms();
+		}
+	}
 
 	if (gss && orig)
 		xasprintf(&newstr, "%s,%s", gss, orig);
--- openssh-9.4p1/sshd_config.5
+++ openssh-9.4p1/sshd_config.5
@@ -238,6 +238,9 @@ is enabled),
 .Qq password
 and
 .Qq publickey .
+.Pp
+.Qq gssapi-keyex
+is not available in FIPS-140 mode.
 .It Cm AuthorizedKeysCommand
 Specifies a program to be used to look up the user's public keys.
 The program must be owned by root, not writable by group or others and
@@ -573,6 +576,13 @@ aes128-ctr,aes192-ctr,aes256-ctr,
 aes128-gcm@openssh.com,aes256-gcm@openssh.com
 .Ed
 .Pp
+The following ciphers are FIPS-140 approved and are supported in FIPS-140 mode:
+.Bd -literal -offset indent
+aes128-ctr,aes192-ctr,aes256-ctr,
+aes128-gcm@openssh.com,aes256-gcm@openssh.com,
+aes128-cbc,3des-cbc,aes192-cbc,aes256-cbc
+.Ed
+.Pp
 The list of available ciphers may also be obtained using
 .Qq ssh -Q cipher .
 .It Cm ClientAliveCountMax
@@ -682,6 +692,8 @@ and
 .Cm sha256 .
 The default is
 .Cm sha256 .
+In FIPS-140 mode the only supported option is
+.Dq sha256 .
 .It Cm ForceCommand
 Forces the execution of the command specified by
 .Cm ForceCommand ,
@@ -737,6 +749,8 @@ Specifies whether key exchange based on
 doesn't rely on ssh keys to verify host identity.
 The default is
 .Cm no .
+.Pp
+GSSAPI key exchange is not available in FIPS-140 mode.
 .It Cm GSSAPIStrictAcceptorCheck
 Determines whether to be strict about the identity of the GSSAPI acceptor
 a client authenticates against.
@@ -1232,6 +1246,16 @@ umac-64@openssh.com,umac-128@openssh.com
 hmac-sha2-256,hmac-sha2-512,hmac-sha1
 .Ed
 .Pp
+The following MACs are FIPS-140 approved and are supported in FIPS-140 mode:
+.Bd -literal -offset indent
+hmac-sha2-256-etm@openssh.com,
+hmac-sha2-512-etm@openssh.com,
+hmac-sha2-256,hmac-sha2-512,
+hmac-sha1-etm@openssh.com,
+hmac-sha1-96-etm@openssh.com
+hmac-sha1,hmac-sha1-96
+.Ed
+.Pp
 The list of available MAC algorithms may also be obtained using
 .Qq ssh -Q mac .
 .It Cm Match
--- openssh-9.4p1/sshkey.c
+++ openssh-9.4p1/sshkey.c
@@ -100,11 +100,9 @@ extern const struct sshkey_impl sshkey_e
 extern const struct sshkey_impl sshkey_ed25519_sk_cert_impl;
 #ifdef WITH_OPENSSL
 # ifdef OPENSSL_HAS_ECC
-#  ifdef ENABLE_SK
 extern const struct sshkey_impl sshkey_ecdsa_sk_impl;
 extern const struct sshkey_impl sshkey_ecdsa_sk_cert_impl;
 extern const struct sshkey_impl sshkey_ecdsa_sk_webauthn_impl;
-#  endif /* ENABLE_SK */
 extern const struct sshkey_impl sshkey_ecdsa_nistp256_impl;
 extern const struct sshkey_impl sshkey_ecdsa_nistp256_cert_impl;
 extern const struct sshkey_impl sshkey_ecdsa_nistp384_impl;
@@ -140,13 +138,46 @@ /* .keybits = */	0,
 	/* .funcs = */		NULL,
 };
 
+#ifdef ENABLE_OPENSSL_FIPS
+/* in FIPS mode limit keytypes to FIPS compliant only */
+#define	keyimpls (ssh_FIPS_mode() ? keyimpls_fips : keyimpls_dflt)
+
+const struct sshkey_impl * const keyimpls_fips[] = {
+#ifdef WITH_OPENSSL
+# ifdef OPENSSL_HAS_ECC
+	&sshkey_ecdsa_nistp256_impl,
+	&sshkey_ecdsa_nistp256_cert_impl,
+	&sshkey_ecdsa_nistp384_impl,
+	&sshkey_ecdsa_nistp384_cert_impl,
+#  ifdef OPENSSL_HAS_NISTP521
+	&sshkey_ecdsa_nistp521_impl,
+	&sshkey_ecdsa_nistp521_cert_impl,
+#  endif /* OPENSSL_HAS_NISTP521 */
+	&sshkey_ecdsa_sk_impl,
+	&sshkey_ecdsa_sk_cert_impl,
+	&sshkey_ecdsa_sk_webauthn_impl,
+# endif /* OPENSSL_HAS_ECC */
+	&sshkey_dss_impl,
+	&sshkey_dsa_cert_impl,
+	&sshkey_rsa_impl,
+	&sshkey_rsa_cert_impl,
+	&sshkey_rsa_sha256_impl,
+	&sshkey_rsa_sha256_cert_impl,
+	&sshkey_rsa_sha512_impl,
+	&sshkey_rsa_sha512_cert_impl,
+#endif /* WITH_OPENSSL */
+	&sshkey_null_impl,
+	NULL
+};
+
+const struct sshkey_impl * const keyimpls_dflt[] = {
+#else /* ENABLE_OPENSSL_FIPS */
 const struct sshkey_impl * const keyimpls[] = {
+#endif /* ENABLE_OPENSSL_FIPS */
 	&sshkey_ed25519_impl,
 	&sshkey_ed25519_cert_impl,
-#ifdef ENABLE_SK
 	&sshkey_ed25519_sk_impl,
 	&sshkey_ed25519_sk_cert_impl,
-#endif
 #ifdef WITH_OPENSSL
 # ifdef OPENSSL_HAS_ECC
 	&sshkey_ecdsa_nistp256_impl,
@@ -157,11 +188,9 @@ #  ifdef OPENSSL_HAS_NISTP521
 	&sshkey_ecdsa_nistp521_impl,
 	&sshkey_ecdsa_nistp521_cert_impl,
 #  endif /* OPENSSL_HAS_NISTP521 */
-#  ifdef ENABLE_SK
 	&sshkey_ecdsa_sk_impl,
 	&sshkey_ecdsa_sk_cert_impl,
 	&sshkey_ecdsa_sk_webauthn_impl,
-#  endif /* ENABLE_SK */
 # endif /* OPENSSL_HAS_ECC */
 	&sshkey_dss_impl,
 	&sshkey_dsa_cert_impl,
