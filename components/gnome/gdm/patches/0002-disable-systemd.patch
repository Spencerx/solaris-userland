From 32964af4bf85ba8668606c8895795ec2af762b2c Mon Sep 17 00:00:00 2001
From: Niveditha Rau <niveditha.rau@oracle.com>
Date: Tue, 29 Dec 2015 11:59:18 -0800
Subject: [PATCH 02/19] disable systemd

--- a/common/gdm-common.c	2023-09-14 08:27:04.000000000 -0700
+++ b/common/gdm-common.c	2024-01-18 20:15:26.955739790 -0800
@@ -36,12 +36,26 @@
 
 #include "gdm-common.h"
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-login.h>
+#endif
 
 #define GDM_DBUS_NAME                            "org.gnome.DisplayManager"
 #define GDM_DBUS_LOCAL_DISPLAY_FACTORY_PATH      "/org/gnome/DisplayManager/LocalDisplayFactory"
 #define GDM_DBUS_LOCAL_DISPLAY_FACTORY_INTERFACE "org.gnome.DisplayManager.LocalDisplayFactory"
 
+#ifdef WITH_CONSOLE_KIT
+#define CK_NAME      "org.freedesktop.ConsoleKit"
+#define CK_PATH      "/org/freedesktop/ConsoleKit"
+#define CK_INTERFACE "org.freedesktop.ConsoleKit"
+
+#define CK_MANAGER_PATH      "/org/freedesktop/ConsoleKit/Manager"
+#define CK_MANAGER_INTERFACE "org.freedesktop.ConsoleKit.Manager"
+#define CK_SEAT_INTERFACE    "org.freedesktop.ConsoleKit.Seat"
+#define CK_SESSION_INTERFACE "org.freedesktop.ConsoleKit.Session"
+#endif
+
+
 G_DEFINE_QUARK (gdm-common-error, gdm_common_error);
 
 gboolean
@@ -354,8 +368,299 @@
         return TRUE;
 }
 
+#ifdef WITH_CONSOLE_KIT
+static gboolean
+get_current_session_id (GDBusConnection  *connection,
+                        char            **session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             CK_MANAGER_PATH,
+                                             CK_MANAGER_INTERFACE,
+                                             "GetCurrentSession",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", session_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static gboolean
+get_seat_id_for_session (GDBusConnection  *connection,
+                         const char       *session_id,
+                         char            **seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             session_id,
+                                             CK_SESSION_INTERFACE,
+                                             "GetSeatId",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine seat: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", seat_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static char *
+get_current_seat_id (GDBusConnection *connection)
+{
+        gboolean res;
+        char    *session_id;
+        char    *seat_id;
+
+        session_id = NULL;
+        seat_id = NULL;
+
+        res = get_current_session_id (connection, &session_id);
+        if (res) {
+                res = get_seat_id_for_session (connection, session_id, &seat_id);
+        }
+        g_free (session_id);
+
+        return seat_id;
+}
+
+static gboolean
+activate_session_id_for_ck (GDBusConnection *connection,
+                            const char      *seat_id,
+                            const char      *session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "ActivateSession",
+                                             g_variant_new ("(o)", session_id),
+                                             NULL,
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to activate session: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static gboolean
+session_is_login_window (GDBusConnection *connection,
+                         const char      *session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char *value;
+        gboolean ret;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             session_id,
+                                             CK_SESSION_INTERFACE,
+                                             "GetSessionType",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(s)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session type: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(&s)", &value);
+
+        if (value == NULL || value[0] == '\0' || strcmp (value, "LoginWindow") != 0) {
+                ret = FALSE;
+        } else {
+                ret = TRUE;
+        }
+
+        g_variant_unref (reply);
+
+        return ret;
+}
+
+static gboolean
+seat_can_activate_sessions (GDBusConnection *connection,
+                            const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        gboolean ret;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "CanActivateSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(b)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine if can activate sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(b)", &ret);
+        g_variant_unref (reply);
+
+        return ret;
+}
+
+static const char **
+seat_get_sessions (GDBusConnection *connection,
+                   const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char **value;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             CK_SEAT_INTERFACE,
+                                             "GetSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(ao)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to list sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+
+        }
+
+        g_variant_get (reply, "(^ao)", &value);
+        g_variant_unref (reply);
+
+        return value;
+}
+
+static gboolean
+get_login_window_session_id_for_ck (GDBusConnection  *connection,
+                                    const char       *seat_id,
+                                    char            **session_id)
+{
+        gboolean     can_activate_sessions;
+        const char **sessions;
+        int          i;
+
+        *session_id = NULL;
+        sessions = NULL;
+
+        g_debug ("checking if seat can activate sessions");
+
+        can_activate_sessions = seat_can_activate_sessions (connection, seat_id);
+        if (! can_activate_sessions) {
+                g_debug ("seat is unable to activate sessions");
+                return FALSE;
+        }
+
+        sessions = seat_get_sessions (connection, seat_id);
+        for (i = 0; sessions [i] != NULL; i++) {
+                const char *ssid;
+
+                ssid = sessions [i];
+
+                if (session_is_login_window (connection, ssid)) {
+                        *session_id = g_strdup (ssid);
+                        break;
+                }
+        }
+        g_free (sessions);
+
+        return TRUE;
+}
+
+static gboolean
+goto_login_session_for_ck (GDBusConnection  *connection,
+			   GCancellable    *cancellable,
+                           GError          **error)
+{
+        gboolean        ret;
+        gboolean        res;
+        char           *session_id;
+        char           *seat_id;
+
+        ret = FALSE;
+
+        /* First look for any existing LoginWindow sessions on the seat.
+           If none are found, create a new one. */
+
+        seat_id = get_current_seat_id (connection);
+        if (seat_id == NULL || seat_id[0] == '\0') {
+                g_debug ("seat id is not set; can't switch sessions");
+                g_set_error (error, GDM_COMMON_ERROR, 0, _("Could not identify the current session."));
+
+                return FALSE;
+        }
+
+        res = get_login_window_session_id_for_ck (connection, seat_id, &session_id);
+        if (! res) {
+                g_set_error (error, GDM_COMMON_ERROR, 1, _("User unable to switch sessions."));
+                return FALSE;
+        }
+
+        if (session_id != NULL) {
+                res = activate_session_id_for_ck (connection, seat_id, session_id);
+                if (res) {
+                        ret = TRUE;
+                }
+        }
+
+        if (! ret && g_strcmp0 (seat_id, "/org/freedesktop/ConsoleKit/Seat1") == 0) {
+                res = create_transient_display (connection, cancellable, error);
+                if (res) {
+                        ret = TRUE;
+                }
+        }
+
+        return ret;
+}
+#endif /* WITH_CONSOLE_KIT */
+
+#ifdef WITH_SYSTEMD
 gboolean
-gdm_activate_session_by_id (GDBusConnection *connection,
+activate_session_id_for_systemd (GDBusConnection *connection,
                             GCancellable    *cancellable,
                             const char      *seat_id,
                             const char      *session_id)
@@ -389,7 +694,7 @@
 }
 
 gboolean
-gdm_get_login_window_session_id (const char  *seat_id,
+gdm_get_login_window_session_id_systemd (const char  *seat_id,
                                  char       **session_id)
 {
         gboolean   ret;
@@ -485,7 +790,7 @@
 }
 
 static gboolean
-goto_login_session (GDBusConnection  *connection,
+goto_login_session_for_systemd (GDBusConnection  *connection,
                     GCancellable     *cancellable,
                     GError          **error)
 {
@@ -543,6 +848,7 @@
 
         return ret;
 }
+#endif /* WITH_SYSTEMD */
 
 gboolean
 gdm_goto_login_session (GCancellable *cancellable,
@@ -558,7 +864,17 @@
                 return FALSE;
         }
 
-        return goto_login_session (connection, cancellable, error);
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return goto_login_session_for_systemd (connection, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return goto_login_session_for_ck (connection, cancellable, error);
+#else
+        return FALSE;
+#endif
 }
 
 static void
@@ -834,6 +1150,7 @@
         return g_string_free (s, FALSE);
 }
 
+#ifdef WITH_SYSTEMD
 static gboolean
 _systemd_session_is_graphical (const char *session_id)
 {
@@ -965,6 +1282,7 @@
 
         return TRUE;
 }
+#endif /* WITH_SYSTEMD */
 
 static void
 load_env_file (GFile *file,

--- a/common/gdm-common.h	2024-01-16 17:39:46.027362076 -0800
+++ b/common/gdm-common.h	2024-01-16 17:42:40.929467973 -0800
@@ -37,6 +37,9 @@
 
 #define GDM_SYSTEMD_SESSION_REQUIRE_ONLINE 0
 
+/* check if logind is running */
+#define LOGIND_RUNNING() (access("/run/systemd/seats/", F_OK) >= 0)
+
 GQuark gdm_common_error_quark (void);
 #define GDM_COMMON_ERROR gdm_common_error_quark()
 
--- a/common/gdm-log.c	2024-01-16 17:43:30.663659411 -0800
+++ b/common/gdm-log.c	2024-01-16 17:49:05.948911379 -0800
@@ -30,7 +30,9 @@
 #include <unistd.h>
 
 #include <syslog.h>
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-daemon.h>
+#endif
 
 #include <glib.h>
 #include <glib/gstdio.h>
@@ -125,12 +127,34 @@
 void
 gdm_log_init (void)
 {
+        const char *prg_name;
+        int         options;
+
         if (initialized)
                 return;
 
         initialized = TRUE;
 
+#ifdef WITH_SYSTEMD
+        is_sd_booted = sd_booted () > 0;
+#endif
         g_log_set_default_handler (gdm_log_default_handler, NULL);
+
+        /* Only set up syslog if !systemd, otherwise with systemd
+         * enabled, we keep the default GLib log handler which goes to
+         * stderr, which is routed to the appropriate place in the
+         * systemd service file.
+         */
+        if (!is_sd_booted) {
+                prg_name = g_get_prgname ();
+
+                options = LOG_PID;
+#ifdef LOG_PERROR
+                options |= LOG_PERROR;
+#endif
+
+                openlog (prg_name, options, LOG_DAEMON);
+        }
 }
 
 void
--- a/daemon/gdm-launch-environment.c	2024-01-16 17:50:03.076234602 -0800
+++ b/daemon/gdm-launch-environment.c	2024-01-16 17:52:26.684893856 -0800
@@ -217,6 +217,9 @@
                 char *seat_id;
 
                 seat_id = launch_environment->x11_display_seat_id;
+                if (g_str_has_prefix (seat_id, "/org/freedesktop/ConsoleKit/")) 		{
+                        seat_id += strlen ("/org/freedesktop/ConsoleKit/");
+                }
 
                 g_hash_table_insert (hash, g_strdup ("GDM_SEAT_ID"), g_strdup (seat_id));
         }
@@ -267,6 +270,7 @@
         while (g_hash_table_iter_next (&iter, &key, &value)) {
                 gdm_session_set_environment_variable (launch_environment->session, key, value);
         }
+ 	gdm_session_select_session_type (launch_environment->session, "LoginWindow");
 }
 
 static void
--- a/daemon/gdm-server.c	2024-01-16 17:53:13.331173844 -0800
+++ b/daemon/gdm-server.c	2024-01-16 17:59:45.008250690 -0800
@@ -43,7 +43,9 @@
 #include <linux/vt.h>
 #endif
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-daemon.h>
+#endif
 
 #ifdef ENABLE_SYSTEMD_JOURNAL
 #include <systemd/sd-journal.h>
@@ -114,11 +116,88 @@
 
 G_DEFINE_TYPE (GdmServer, gdm_server, G_TYPE_OBJECT)
 
+static char *
+_gdm_server_query_ck_for_display_device (GdmServer *server)
+{
+        char    *out;
+        char    *command;
+        int      status;
+        gboolean res;
+        GError  *error;
+
+        g_return_val_if_fail (GDM_IS_SERVER (server), NULL);
+
+
+        error = NULL;
+        command = g_strdup_printf ("/usr/lib/ck-get-x11-display-device --display %s",
+                                   server->display_name);
+        g_debug ("GdmServer: Running helper %s", command);
+        out = NULL;
+        res = g_spawn_command_line_sync (command,
+                                         &out,
+                                         NULL,
+                                         &status,
+                                         &error);
+        g_free (command);
+
+        if (! res) {
+                g_warning ("Could not run helper: %s", error->message);
+                g_error_free (error);
+                g_free (out);
+                return NULL;
+        }
+        out = g_strstrip (out);
+
+        /* There are several scenarios that the device will be "?"
+         * 1. Local sessions without VT support. If the display is ":0",
+         *    we set the device as "/dev/console" to gain device permissions.
+         *    This only happens on those systems do not has VT support such as
+         *    old Solaris. So far, Linux and OpenSolaris with VT support.
+         * 2. XDMCP sessions, we set device as "/dev/dtremote"
+         * 3. Local sessions like Sun Ray, Xvfb, Xvnc, we set device as
+         *    "/dev/dtlocal"
+         */
+        if (g_str_equal (out, "?")) {
+                if (!server->is_local) {
+                        /* This is for XDMCP sessions. */
+                        out = g_strdup ("/dev/dtremote");
+                } else  {
+                        if (g_str_equal (server->display_name, ":0")) {
+                                /* This is for local session run on console. */
+                                out = g_strdup ("/dev/console");
+                        } else {
+                                /* This is for local sessions like
+                                 * Sun Ray, Xvfb, Xvnc, etc. */
+                                out = g_strdup ("/dev/dtlocal");
+                        }
+                }
+        }
+
+        g_debug ("GdmServer: Got tty: '%s'", out);
+
+        return out;
+}
+
+
 char *
 gdm_server_get_display_device (GdmServer *server)
 {
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
         /* systemd finds the display device out on its own based on the display */
         return NULL;
+        }
+#endif
+
+        if (server->display_device == NULL) {
+                server->display_device =
+                    _gdm_server_query_ck_for_display_device (server);
+
+                g_object_notify (G_OBJECT (server), "display-device");
+
+        }
+
+        return g_strdup (server->display_device);
 }
 
 static void
@@ -220,6 +299,8 @@
 
 #define X_SERVER_ARG_FORMAT " -background none -noreset -verbose %s%s"
 
+#ifdef WITH_SYSTEMD
+
         /* This is a temporary hack to work around the fact that XOrg
          * currently lacks support for multi-seat hotplugging for
          * display devices. This bit should be removed as soon as XOrg
@@ -234,6 +315,10 @@
          * wasn't booted using systemd, or b) the wrapper tool is
          * missing, or c) we are running for the main seat 'seat0'. */
 
+        if (!LOGIND_RUNNING()) {
+                goto fallback;
+        }
+
 #ifdef ENABLE_SYSTEMD_JOURNAL
         /* For systemd, we don't have a log file but instead log to stdout,
            so set it to the xserver's built-in default verbosity */
@@ -256,6 +341,7 @@
         return;
 
 fallback:
+#endif
         server->command = g_strdup_printf (X_SERVER X_SERVER_ARG_FORMAT, verbosity, debug_options);
 
 }
@@ -307,10 +393,12 @@
                 argv[len++] = g_strdup (server->auth_file);
         }
 
-        if (server->display_seat_id != NULL) {
+#ifdef WITH_SYSTEMD
+	if (LOGIND_RUNNING() && server->display_seat_id != NULL) {
                 argv[len++] = g_strdup ("-seat");
                 argv[len++] = g_strdup (server->display_seat_id);
         }
+#endif
 
         /* If we were compiled with Xserver >= 1.17 we need to specify
          * '-listen tcp' as the X server dosen't listen on tcp sockets
--- a/daemon/gdm-session-record.c	2020-06-19 16:43:50.769119645 -0700
+++ b/daemon/gdm-session-record.c	2020-06-19 16:46:57.687928197 -0700
@@ -33,6 +33,16 @@
 #include <utmp.h>
 #endif
 
+#if defined(HAVE_UTIL_H)
+#include <util.h>
+#endif
+
+#if defined(HAVE_GETTTYENT)
+#include <fcntl.h> /* open(2) */
+#include <ttyent.h>
+static int fd = -1;
+#endif
+
 #include <glib.h>
 #include <glib/gi18n.h>
 #include <glib/gstdio.h>
@@ -43,6 +53,9 @@
 #define GDM_BAD_SESSION_RECORDS_FILE "/var/log/btmp"
 #endif
 
+static void write_utmp_login_manually (struct utmp *ut);
+static void write_utmp_logout_manually (char *);
+
 #if !defined(GDM_NEW_SESSION_RECORDS_FILE)
 #    if defined(WTMPX_FILE)
 #        define GDM_NEW_SESSION_RECORDS_FILE WTMPX_FILE
@@ -168,6 +181,85 @@
         g_debug ("using ut_line %.*s", (int) sizeof (u->ut_line), u->ut_line);
 }
 
+static void
+write_utmp_login_manually (struct utmp *ut)
+{
+#if defined(HAVE_GETTTYENT) && defined(HAVE_UTMP_H)
+        UTMP ubuf;
+        int topslot = -1;
+
+        g_debug ("Adding new utmp record");
+
+        /*
+         * First, loop through /etc/ttys, if needed, to initialize the
+         * top of the tty slots, since gdm has no tty.
+         */
+        if (topslot < 0) {
+                topslot = 0;
+                while (getttyent () != (struct ttyent *) NULL)
+                        topslot++;
+        }
+        if ((topslot < 0) || ((fd < 0) &&
+            (fd = open (_PATH_UTMP, O_RDWR|O_CREAT, 0644)) < 0))
+                return;
+
+        /*
+         * Now find a slot that's not in use...
+         */
+        (void) lseek (fd, (off_t) (topslot * sizeof (struct utmp)), SEEK_SET);
+
+        while (1) {
+                if (read (fd, &ubuf, sizeof (struct utmp)) ==
+                    sizeof (struct utmp)) {
+                        if (!ubuf.ut_name[0]) {
+                                (void) lseek (fd, -(off_t) sizeof (struct utmp),
+                                    SEEK_CUR);
+                                break;
+                        }
+                        topslot++;
+                } else {
+                        (void) lseek (fd, (off_t) (topslot *
+                            sizeof (struct utmp)), SEEK_SET);
+                        break;
+                }
+        }
+
+        (void) write (fd, ut, sizeof (struct utmp));
+#endif
+}
+
+static void
+write_utmp_logout_manually (char *line)
+{
+#if defined(HAVE_GETTTYENT) && defined(HAVE_UTMP_H)
+        int rval = 1;
+        struct timeval tv;
+        UTMP ut;
+
+        g_debug ("Removing utmp record");
+
+
+        if (fd >= 0) {
+            (void) lseek (fd, 0, SEEK_SET);
+            while (read (fd, &ut, sizeof (struct utmp)) == sizeof (struct utmp)) {
+                    if (!ut.ut_name[0] ||
+                        strncmp (ut.ut_line, line, UT_LINESIZE))
+                            continue;
+                    bzero (ut.ut_name, UT_NAMESIZE);
+                    bzero (ut.ut_host, UT_HOSTSIZE);
+                    gettimeofday (&tv, NULL);
+                    ut.ut_time = tv.tv_sec;
+                    (void) lseek (fd, -(off_t) sizeof (struct utmp), SEEK_CUR);
+                    (void) write (fd, &ut, sizeof (struct utmp));
+                    rval = 0;
+            }
+        }
+
+        if (rval != 0)
+            g_debug ("Failed to remove utmp record");
+#endif
+}
+
 void
 gdm_session_record_login (GPid                  session_pid,
                           const char           *user_name,
@@ -214,8 +306,9 @@
         setutxent();
         pututxline (&session_record);
         endutxent();
-#elif defined(HAVE_LOGIN)
-	login (&session_record);
+#else
+        if (strcmp (session_record.ut_name, "(unknown)") != 0)
+            write_utmp_login_manually (&session_record);
 #endif
 }
 
@@ -259,8 +352,8 @@
         setutxent();
         pututxline (&session_record);
         endutxent();
-#elif defined(HAVE_LOGOUT)
-        logout (session_record.ut_line);
+#else
+        write_utmp_logout_manually (session_record.ut_line);
 #endif
 }
 
--- a/daemon/gdm-session-worker-job.c	2020-06-19 16:48:36.498759352 -0700
+++ b/daemon/gdm-session-worker-job.c	2020-06-19 16:49:04.156698208 -0700
@@ -36,7 +36,9 @@
 #include <sys/prctl.h>
 #endif
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-daemon.h>
+#endif
 
 #ifdef ENABLE_SYSTEMD_JOURNAL
 #include <systemd/sd-journal.h>
--- a/daemon/gdm-session-worker.xml	2020-06-19 17:35:15.020804547 -0700
+++ b/daemon/gdm-session-worker.xml	2020-06-19 17:35:42.184445075 -0700
@@ -13,6 +13,9 @@
     <method name="SetSessionName">
       <arg name="session_name" direction="in" type="s" />
     </method>
+    <method name="SetSessionType">
+      <arg name="session_type" direction="in" type="s"/>
+    </method>
     <method name="SetSessionDisplayMode">
       <arg name="mode" direction="in" type="s"/>
     </method>
--- a/daemon/gdm-session.h	2020-06-19 17:39:51.038979495 -0700
+++ b/daemon/gdm-session.h	2020-06-19 17:40:21.330457006 -0700
@@ -122,6 +122,8 @@
                                                            const char *text);
 void              gdm_session_select_program              (GdmSession *session,
                                                            const char *command_line);
+void              gdm_session_select_session_type         (GdmSession *session,
+                                                           const char *session_type);
 void              gdm_session_select_session              (GdmSession *session,
                                                            const char *session_name);
 void              gdm_session_select_user                 (GdmSession *session,
--- a/daemon/gdm-server.c	2024-01-16 19:35:08.315380457 -0800
+++ b/daemon/gdm-server.c	2024-01-16 19:43:26.939753971 -0800
@@ -88,6 +88,7 @@
         guint    child_watch_id;
 
         gboolean is_initial;
+ 	gboolean is_local;
 };
 
 enum {
--- a/common/meson.build	2024-01-17 16:23:52.877705743 -0800
+++ b/common/meson.build	2024-01-17 16:23:57.922940863 -0800
@@ -11,7 +11,6 @@
 )
 
 libgdmcommon_deps = [
-  logind_dep,
   gobject_dep,
   gio_dep,
   gio_unix_dep,
--- a/libgdm/meson.build	2024-01-17 16:24:31.147831655 -0800
+++ b/libgdm/meson.build	2024-01-17 16:24:43.917513328 -0800
@@ -56,7 +56,6 @@
   glib_dep,
   gio_dep,
   gio_unix_dep,
-  logind_dep,
   libgdmcommon_dep,
 ]
 
--- a/daemon/gdm-session-worker.c	2024-01-16 19:57:55.657753313 -0800
+++ b/daemon/gdm-session-worker.c	2024-01-17 16:27:15.059040762 -0800
@@ -28,9 +28,11 @@
 #include <string.h>
 #include <sys/types.h>
 #include <sys/wait.h>
+#ifdef WITH_SYSTEMD
 #include <sys/ioctl.h>
 #include <sys/vt.h>
 #include <sys/kd.h>
+#endif
 #include <errno.h>
 #include <grp.h>
 #include <pwd.h>
@@ -49,8 +51,10 @@
 
 #include <X11/Xauth.h>
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-daemon.h>
 #include <systemd/sd-login.h>
+#endif
 
 #ifdef ENABLE_SYSTEMD_JOURNAL
 #include <systemd/sd-journal.h>
@@ -126,6 +130,10 @@
 
         int               exit_code;
 
+#ifdef WITH_CONSOLE_KIT
+        char             *session_cookie;
+#endif
+
         pam_handle_t     *pam_handle;
 
         GPid              child_pid;
@@ -140,6 +148,7 @@
         char             *hostname;
         char             *username;
         char             *log_file;
+	char		 *session_type;
         char             *session_id;
         uid_t             uid;
         gid_t             gid;
@@ -214,6 +223,204 @@
                          G_IMPLEMENT_INTERFACE (GDM_DBUS_TYPE_WORKER,
                                                 worker_interface_init))
 
+#ifdef WITH_CONSOLE_KIT
+static gboolean                              
+open_ck_session (GdmSessionWorker  *worker)
+{       
+        GDBusConnection  *system_bus;
+        GVariantBuilder   builder;
+        GVariant         *parameters;
+        GVariant         *in_args;
+        struct passwd    *pwent;
+        GVariant         *reply;
+        GError           *error = NULL;
+        const char       *display_name;
+        const char       *display_device;
+        const char       *display_hostname;
+        const char       *session_type;
+        gint32            uid; 
+        
+        g_assert (worker->session_cookie == NULL);
+
+        if (worker->x11_display_name != NULL) {
+                display_name = worker->x11_display_name;
+        } else {
+                display_name = "";
+        }
+        if (worker->hostname != NULL) {
+        
+                display_hostname = worker->hostname;
+        } else {
+                display_hostname = "";
+        }
+        if (worker->display_device != NULL) {
+                display_device = worker->display_device;
+        } else {                             
+                display_device = "";
+        }                                    
+
+        if (worker->session_type != NULL) {
+                session_type = worker->session_type;
+        } else {                             
+                session_type = "";           
+        }                                    
+                                             
+        g_assert (worker->username != NULL);
+
+        
+        gdm_get_pwent_for_name (worker->username, &pwent);
+        if (pwent == NULL) {
+                goto out;                    
+        }                                    
+
+        uid = (gint32) pwent->pw_uid;
+        error = NULL;
+        system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, &error);
+
+        if (system_bus == NULL) {
+                g_warning ("Couldn't create connection to system bus: %s",
+                           error->message);
+
+                g_error_free (error);
+                goto out;
+        }
+
+        g_variant_builder_init (&builder, G_VARIANT_TYPE ("a(sv)"));
+        g_variant_builder_add_parsed (&builder, "('unix-user', <%i>)", uid);
+        g_variant_builder_add_parsed (&builder, "('x11-display-device', <%s>)", display_device);
+        g_variant_builder_add_parsed (&builder, "('x11-display', <%s>)", display_name);
+        g_variant_builder_add_parsed (&builder, "('remote-host-name', <%s>)", display_hostname);
+        g_variant_builder_add_parsed (&builder, "('is-local', <%b>)", worker->display_is_local);
+        g_variant_builder_add_parsed (&builder, "('session-type', <%s>)", session_type);
+
+        parameters = g_variant_builder_end (&builder);
+        in_args = g_variant_new_tuple (&parameters, 1);
+        reply = g_dbus_connection_call_sync (system_bus,
+                                             "org.freedesktop.ConsoleKit",
+                                             "/org/freedesktop/ConsoleKit/Manager",
+                                             "org.freedesktop.ConsoleKit.Manager",
+                                             "OpenSessionWithParameters",
+                                             in_args,
+                                             G_VARIANT_TYPE ("(s)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             &error);
+
+        if (! reply) {
+                g_warning ("%s\n", error->message);
+                g_clear_error (&error);
+                goto out;
+        }
+
+        g_variant_get (reply, "(s)", &worker->session_cookie);
+
+        g_variant_unref (reply);
+
+out:
+        return worker->session_cookie != NULL;
+}
+
+static void
+close_ck_session (GdmSessionWorker *worker)
+{
+        GDBusConnection  *system_bus;
+        GVariant         *reply;
+        GError           *error = NULL;
+        gboolean          was_closed;
+
+        if (worker->session_cookie == NULL) {
+                return;
+        }
+
+        error = NULL;
+        system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, &error);
+
+
+        if (system_bus == NULL) {
+                g_warning ("Couldn't create connection to system bus: %s",
+                           error->message);
+
+                g_error_free (error);
+                goto out;
+        }
+
+        reply = g_dbus_connection_call_sync (system_bus,
+                                             "org.freedesktop.ConsoleKit",
+                                             "/org/freedesktop/ConsoleKit/Manager",
+                                             "org.freedesktop.ConsoleKit.Manager",
+                                             "CloseSession",
+                                             g_variant_new ("(s)", worker->session_cookie),
+                                             G_VARIANT_TYPE ("(b)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             &error);
+
+        if (! reply) {
+                g_warning ("%s", error->message);
+                g_clear_error (&error);
+                goto out;
+        }
+
+        g_variant_get (reply, "(b)", &was_closed);
+
+        if (!was_closed) {
+                g_warning ("Unable to close ConsoleKit session");
+        }
+
+        g_variant_unref (reply);
+
+out:
+        g_clear_pointer (&worker->session_cookie,
+                         (GDestroyNotify) g_free);
+}
+
+static char *
+get_ck_session_id (GdmSessionWorker *worker)
+{
+        GDBusConnection  *system_bus;
+        GVariant         *reply;
+        GError           *error = NULL;
+        char             *session_id = NULL;
+
+        error = NULL;
+        system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, &error);
+
+        if (system_bus == NULL) {
+                g_warning ("Couldn't create connection to system bus: %s",
+                           error->message);
+
+                g_error_free (error);
+                goto out;
+        }
+        reply = g_dbus_connection_call_sync (system_bus,
+                                             "org.freedesktop.ConsoleKit",
+                                             "/org/freedesktop/ConsoleKit/Manager",
+                                             "org.freedesktop.ConsoleKit.Manager",
+                                             "GetSessionForCookie",
+                                             g_variant_new ("(s)", worker->session_cookie),
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             &error);
+
+        if (reply == NULL) {
+                g_warning ("%s", error->message);
+                g_clear_error (&error);
+                goto out;
+        }
+
+        g_variant_get (reply, "(o)", &session_id);
+
+        g_variant_unref (reply);
+
+out:
+        return session_id;
+}
+#endif /* WITH_CONSOLE_KIT */
+
 /* adapted from glib script_execute */
 static void
 script_execute (const gchar *file,
@@ -902,6 +1109,7 @@
         worker->auditor = NULL;
 }
 
+#ifdef WITH_SYSTEMD
 static void
 on_release_display (int signal)
 {
@@ -1044,6 +1252,7 @@
 
         close (active_vt_tty_fd);
 }
+#endif
 
 static void
 gdm_session_worker_set_state (GdmSessionWorker      *worker,
@@ -1214,10 +1423,12 @@
                 }
         }
 
+#ifdef WITH_SYSTEMD
         /* set seat ID */
-        if (seat_id != NULL && seat_id[0] != '\0') {
+        if (seat_id != NULL && seat_id[0] != '\0' && LOGIND_RUNNING()) {
                 gdm_session_worker_set_environment_variable (worker, "XDG_SEAT", seat_id);
         }
+#endif
 
         if (strcmp (service, "gdm-launch-environment") == 0) {
                 gdm_session_worker_set_environment_variable (worker, "XDG_SESSION_CLASS", "greeter");
@@ -1226,6 +1437,7 @@
         g_debug ("GdmSessionWorker: state SETUP_COMPLETE");
         gdm_session_worker_set_state (worker, GDM_SESSION_WORKER_STATE_SETUP_COMPLETE);
 
+#ifdef WITH_SYSTEMD
         if (g_strcmp0 (seat_id, "seat0") == 0 && worker->seat0_has_vts) {
                 /* Temporarily set PAM_TTY with the login VT,
                    PAM_TTY will be reset with the users VT right before the user session is opened */
@@ -1232,6 +1444,7 @@
                 g_snprintf (tty_string, 256, "/dev/tty%d", GDM_INITIAL_VT);
                 pam_set_item (worker->pam_handle, PAM_TTY, tty_string);
         }
+#endif
 
         if (!display_is_local)
                 worker->password_is_required = TRUE;
@@ -1674,6 +1887,27 @@
         return (const char * const *) pam_getenvlist (worker->pam_handle);
 }
 
+#ifdef WITH_CONSOLE_KIT
+static void
+register_ck_session (GdmSessionWorker *worker)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return;
+        }
+#endif
+
+        open_ck_session (worker);
+
+        if (worker->session_cookie != NULL) {
+                gdm_session_worker_set_environment_variable (worker,
+                                                             "XDG_SESSION_COOKIE",
+                                                             worker->session_cookie);
+        }
+}
+#endif /* WITH_CONSOLE_KIT */
+
+
 static gboolean
 run_script (GdmSessionWorker *worker,
             const char       *dir)
@@ -1690,6 +1924,7 @@
                                worker->x11_authority_file);
 }
 
+#ifdef WITH_SYSTEMD
 static void
 wait_until_dbus_signal_emission_to_manager_finishes (GdmSessionWorker *worker)
 {
@@ -1736,6 +1971,7 @@
         worker->session_vt = 0;
 #endif
 }
+#endif
 
 static void
 session_worker_child_watch (GPid              pid,
@@ -1751,6 +1987,10 @@
                  : WIFSIGNALED (status) ? WTERMSIG (status)
                  : -1);
 
+#ifdef WITH_CONSOLE_KIT
+        close_ck_session (worker);
+#endif
+
         gdm_session_worker_uninitialize_pam (worker, PAM_SUCCESS);
 
         worker->child_pid = -1;
@@ -1760,8 +2000,9 @@
         gdm_dbus_worker_emit_session_exited (GDM_DBUS_WORKER (worker),
                                              worker->service,
                                              status);
-
+#ifdef WITH_SYSTEMD
         killpg (pid, SIGHUP);
+#endif
 
         /* FIXME: It's important to give the manager an opportunity to process the
          * session-exited emission above before switching VTs.
@@ -1782,9 +2023,11 @@
          * for some ideas and more discussion.
          *
          */
+#ifdef WITH_SYSTEMD
         wait_until_dbus_signal_emission_to_manager_finishes (worker);
 
         jump_back_to_initial_vt (worker);
+#endif
 }
 
 static void
@@ -1951,6 +2194,7 @@
 
         error_code = PAM_SUCCESS;
 
+#ifdef WITH_SYSTEMD
         /* If we're in new vt mode, jump to the new vt now. There's no need to jump for
          * the other two modes: in the logind case, the session will activate itself when
          * ready, and in the reuse server case, we're already on the correct VT. */
@@ -1959,6 +2203,7 @@
                         jump_to_vt (worker, worker->session_vt);
                 }
         }
+#endif
 
         if (!worker->is_program_session && !run_script (worker, GDMCONFDIR "/PostLogin")) {
                 g_set_error (error,
@@ -2021,6 +2266,7 @@
                         _exit (EXIT_FAILURE);
                 }
 
+#ifdef WITH_SYSTEMD
                 /* Take control of the tty
                  */
                 if (needs_controlling_terminal) {
@@ -2028,6 +2274,7 @@
                                 g_debug ("GdmSessionWorker: could not take control of tty: %m");
                         }
                 }
+#endif
 
 #ifdef HAVE_LOGINCAP
                 if (setusercontext (NULL, passwd_entry, passwd_entry->pw_uid, LOGIN_SETALL) < 0) {
@@ -2156,6 +2403,7 @@
         return TRUE;
 }
 
+#ifdef WITH_SYSTEMD
 static gboolean
 set_up_for_new_vt (GdmSessionWorker *worker)
 {
@@ -2255,6 +2503,7 @@
         close (fd);
         return FALSE;
 }
+#endif
 
 static gboolean
 set_up_for_current_vt (GdmSessionWorker  *worker,
@@ -2324,6 +2573,7 @@
          }
 #endif
 
+#ifdef WITH_SYSTEMD
         if (g_strcmp0 (worker->display_seat_id, "seat0") == 0 && worker->seat0_has_vts) {
                 g_debug ("GdmSessionWorker: setting XDG_VTNR to current vt");
                 set_xdg_vtnr_to_current_vt (worker);
@@ -2330,7 +2580,7 @@
         } else {
                 g_debug ("GdmSessionWorker: not setting XDG_VTNR since no VTs on seat");
         }
-
+#endif
         return TRUE;
 }
 
@@ -2352,6 +2602,7 @@
                                 return FALSE;
                         }
                         break;
+#ifdef WITH_SYSTEMD
                 case GDM_SESSION_DISPLAY_MODE_NEW_VT:
                 case GDM_SESSION_DISPLAY_MODE_LOGIND_MANAGED:
                         if (!set_up_for_new_vt (worker)) {
@@ -2362,6 +2613,7 @@
                                 return FALSE;
                         }
                         break;
+#endif
                 }
         }
 
@@ -2384,8 +2636,18 @@
         g_debug ("GdmSessionWorker: state SESSION_OPENED");
         gdm_session_worker_set_state (worker, GDM_SESSION_WORKER_STATE_SESSION_OPENED);
 
+#ifdef WITH_SYSTEMD
         session_id = gdm_session_worker_get_environment_variable (worker, "XDG_SESSION_ID");
+#endif
 
+#ifdef WITH_CONSOLE_KIT
+        register_ck_session (worker);
+
+        if (session_id == NULL) {
+                session_id = get_ck_session_id (worker);
+        }
+#endif
+
         if (session_id != NULL) {
                 g_free (worker->session_id);
                 worker->session_id = g_steal_pointer (&session_id);
@@ -2495,6 +2757,20 @@
 }
 
 static gboolean
+gdm_session_worker_handle_set_session_type (GdmDBusWorker         *object,
+                                            GDBusMethodInvocation *invocation,
+                                            const char            *session_type)
+{
+        GdmSessionWorker *worker = GDM_SESSION_WORKER (object);
+        g_debug ("GdmSessionWorker: session type set to %s", session_type);
+        g_free (worker->session_type);
+        worker->session_type = g_strdup (session_type);
+        gdm_dbus_worker_complete_set_session_type (object, invocation);
+        return TRUE;
+}
+
+
+static gboolean
 gdm_session_worker_handle_set_session_display_mode (GdmDBusWorker         *object,
                                                     GDBusMethodInvocation *invocation,
                                                     const char            *str)
@@ -3437,6 +3713,7 @@
         interface->handle_open = gdm_session_worker_handle_open;
         interface->handle_set_language_name = gdm_session_worker_handle_set_language_name;
         interface->handle_set_session_name = gdm_session_worker_handle_set_session_name;
+        interface->handle_set_session_type = gdm_session_worker_handle_set_session_type;
         interface->handle_set_session_display_mode = gdm_session_worker_handle_set_session_display_mode;
         interface->handle_set_environment_variable = gdm_session_worker_handle_set_environment_variable;
         interface->handle_start_program = gdm_session_worker_handle_start_program;
@@ -3538,7 +3815,9 @@
                 gdm_session_worker_uninitialize_pam (worker, PAM_SUCCESS);
         }
 
+#ifdef WITH_SYSTEMD
         jump_back_to_initial_vt (worker);
+#endif
 
         g_clear_object (&worker->user_settings);
         g_free (worker->service);
--- a/meson.build	2024-01-18 15:41:36.212020731 -0800
+++ b/meson.build	2024-01-18 15:45:53.208110994 -0800
@@ -39,10 +39,6 @@
 # Common variables
 config_h_dir = include_directories('.')
 
-# Dependencies
-udev_dep = dependency('udev')
-gudev_dep = dependency('gudev-1.0', version: '>= 232')
-
 glib_min_version = '2.56.0'
 
 glib_dep = dependency('glib-2.0', version: '>=' + glib_min_version)
@@ -56,16 +52,6 @@
 keyutils_dep = dependency('libkeyutils', required: false)
 libselinux_dep = dependency('libselinux', required: get_option('selinux'))
 
-# udev
-if udev_dir == ''
-  if udev_dep.found()
-    udev_prefix = udev_dep.get_pkgconfig_variable('udevdir')
-  else
-    udev_prefix = gdm_prefix / 'lib' / 'udev'
-  endif
-  udev_dir = udev_prefix / 'rules.d'
-endif
-
 # X11
 x_deps = declare_dependency(
   dependencies: [
@@ -99,25 +85,6 @@
 if xdmcp_dep.found() and get_option('tcp-wrappers')
   libwrap_dep = cc.find_library('wrap')
 endif
-# systemd
-logind_provider = get_option('logind-provider')
-systemd_dep = dependency('systemd', required: false)
-if logind_provider == 'systemd'
-  libsystemd_dep = dependency('libsystemd')
-  logind_dep = libsystemd_dep
-  systemd_multiseat_x = find_program('systemd-multi-seat-x',
-    required: false,
-    dirs: [
-      systemd_dep.get_pkgconfig_variable('systemdutildir'),
-      '/lib/systemd',
-      '/usr/lib/systemd',
-    ])
-  systemd_x_server = systemd_multiseat_x.found()? systemd_multiseat_x.path() : '/lib/systemd/systemd-multi-seat-x'
-else
-  elogind_dep = dependency('libelogind')
-  logind_dep = elogind_dep
-  systemd_x_server = 'disabled'
-endif
 # Plymouth
 plymouth_dep = dependency('ply-boot-client', required: get_option('plymouth'))
 # Check for Solaris auditing API (ADT)
@@ -248,11 +215,9 @@
 conf.set_quoted('GDM_USERNAME', get_option('user'))
 conf.set_quoted('GDM_GROUPNAME', get_option('group'))
 conf.set('HAVE_LIBXDMCP', xdmcp_dep.found())
-conf.set_quoted('SYSTEMD_X_SERVER', systemd_x_server)
 conf.set('WITH_PLYMOUTH', plymouth_dep.found())
 conf.set_quoted('X_SERVER', x_bin)
 conf.set_quoted('X_PATH', x_path)
-conf.set('HAVE_UDEV', gudev_dep.found())
 conf.set('HAVE_UT_UT_HOST', utmp_has_host_field)
 conf.set('HAVE_UT_UT_PID', utmp_has_pid_field)
 conf.set('HAVE_UT_UT_ID', utmp_has_id_field)
@@ -321,7 +286,6 @@
     'Udev rules': udev_dir,
     'XServer': x_bin,
     'XPath': x_path,
-    'Systemd XServer': systemd_x_server,
   },
   section: 'Paths',
 )
--- a/daemon/meson.build	2024-01-18 17:09:22.719219856 -0800
+++ b/daemon/meson.build	2024-01-18 17:09:36.855597592 -0800
@@ -205,10 +205,6 @@
   ]
 endif
 
-if gudev_dep.found()
-  gdm_daemon_deps += gudev_dep
-endif
-
 gdm_daemon = executable('gdm',
   [ gdm_daemon_sources, gdm_daemon_gen_sources ],
   dependencies: gdm_daemon_deps,
--- a/daemon/gdm-session-worker.c	2024-01-18 19:59:42.855782909 -0800
+++ b/daemon/gdm-session-worker.c	2024-01-18 20:00:05.085300436 -0800
@@ -3557,7 +3557,9 @@
                 }
         }
 
+#ifdef WITH_SYSTEMD
         worker->seat0_has_vts = sd_seat_can_tty ("seat0");
+#endif
 
         worker->pending_invocation = invocation;
 
--- a/daemon/gdm-manager.c	2024-01-18 20:16:14.473555178 -0800
+++ b/daemon/gdm-manager.c	2024-01-18 20:12:14.370339575 -0800
@@ -41,7 +41,9 @@
 
 #include <act/act-user-manager.h>
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-login.h>
+#endif
 
 #include "gdm-common.h"
 
@@ -67,6 +69,15 @@
 #define INITIAL_SETUP_USERNAME "gnome-initial-setup"
 #define ALREADY_RAN_INITIAL_SETUP_ON_THIS_BOOT GDM_RUN_DIR "/gdm.ran-initial-setup"
 
+#define CK_NAME      "org.freedesktop.ConsoleKit"
+#define CK_PATH      "/org/freedesktop/ConsoleKit"
+#define CK_INTERFACE "org.freedesktop.ConsoleKit"
+
+#define CK_MANAGER_PATH      "/org/freedesktop/ConsoleKit/Manager"
+#define CK_MANAGER_INTERFACE "org.freedesktop.ConsoleKit.Manager"
+#define CK_SEAT_INTERFACE    "org.freedesktop.ConsoleKit.Seat"
+#define CK_SESSION_INTERFACE "org.freedesktop.ConsoleKit.Session"
+
 typedef struct
 {
         GdmManager *manager;
@@ -208,8 +219,9 @@
 }
 #endif
 
+#ifdef WITH_SYSTEMD
 static char *
-get_session_id_for_pid (pid_t    pid,
+get_session_id_for_pid_systemd (pid_t    pid,
                         GError **error)
 {
         char *session, *gsession;
@@ -235,9 +247,59 @@
                 return NULL;
         }
 }
+#endif
 
+#ifdef WITH_CONSOLE_KIT
+static char *
+get_session_id_for_pid_consolekit (GDBusConnection  *connection,
+                                   pid_t             pid,
+                                   GError          **error)
+{
+        GVariant *reply;
+        char *retval;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             "/org/freedesktop/ConsoleKit/Manager",
+                                             "org.freedesktop.ConsoleKit.Manager",
+                                             "GetSessionForUnixProcess",
+                                             g_variant_new ("(u)", pid),
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, error);
+        if (reply == NULL) {
+                return NULL;
+        }
+
+        g_variant_get (reply, "(o)", &retval);
+        g_variant_unref (reply);
+
+        return retval;
+}
+#endif
+
+static char *
+get_session_id_for_pid (GDBusConnection  *connection,
+                        pid_t             pid,
+                        GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_session_id_for_pid_systemd (pid, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return get_session_id_for_pid_consolekit (connection, pid, error);
+#endif
+
+        return NULL;
+}
+
+#ifdef WITH_SYSTEMD
 static gboolean
-get_uid_for_session_id (const char  *session_id,
+get_uid_for_systemd_session_id (const char  *session_id,
                         uid_t       *uid,
                         GError     **error)
 {
@@ -256,8 +318,62 @@
 
         return TRUE;
 }
+#endif
 
+#ifdef WITH_CONSOLE_KIT
 static gboolean
+get_uid_for_consolekit_session_id (GDBusConnection  *connection,
+                                   const char       *session_id,
+                                   uid_t            *out_uid,
+                                   GError          **error)
+{
+        GVariant *reply;
+        guint32 uid;  
+                      
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",      
+                                             "GetUnixUser",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(u)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) { 
+                return FALSE;
+        }
+        
+        g_variant_get (reply, "(u)", &uid);
+        g_variant_unref (reply);
+
+        *out_uid = (uid_t) uid;
+
+        return TRUE;
+}
+#endif
+
+static gboolean
+get_uid_for_session_id (GDBusConnection  *connection,
+                        const char       *session_id,
+                        uid_t            *uid,
+                        GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_uid_for_systemd_session_id (session_id, uid, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return get_uid_for_consolekit_session_id (connection, session_id, uid, error);
+#endif
+
+        return FALSE;
+}
+
+static gboolean
 lookup_by_session_id (const char *id,
                       GdmDisplay *display,
                       gpointer    user_data)
@@ -269,8 +385,48 @@
         return g_strcmp0 (current, looking_for) == 0;
 }
 
+#ifdef WITH_CONSOLE_KIT
 static gboolean
-is_login_session (GdmManager  *self,
+is_consolekit_login_session (GdmManager       *self,
+                             GDBusConnection  *connection,
+                             const char       *session_id,
+                             GError          **error)
+{
+        GVariant *reply;
+        char *session_type = NULL;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetSessionType",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(s)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(s)", &session_type);
+        g_variant_unref (reply);
+
+        if (g_strcmp0 (session_type, "LoginWindow") != 0) {
+                g_free (session_type);
+
+                return FALSE;
+        }
+
+        g_free (session_type);
+        return TRUE;
+}
+#endif
+
+#ifdef WITH_SYSTEMD
+static gboolean
+is_systemd_login_session (GdmManager  *self,
                   const char  *session_id,
                   GError     **error)
 {
@@ -297,9 +453,122 @@
         g_free (session_class);
         return TRUE;
 }
+#endif
 
 static gboolean
-session_unlock (GdmManager *manager,
+is_login_session (GdmManager       *self,
+                  GDBusConnection  *connection,
+                  const char       *session_id,
+                  GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return is_systemd_login_session (self, session_id, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return is_consolekit_login_session (self, connection, session_id, error);
+#endif
+
+        return FALSE;
+}
+
+#ifdef WITH_SYSTEMD
+static gboolean
+activate_session_id_for_systemd (GdmManager   *manager,
+                                 const char *seat_id,
+                                 const char *session_id)
+{      
+        GError *error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (manager->connection,
+                                             "org.freedesktop.login1",
+                                             "/org/freedesktop/login1",
+                                             "org.freedesktop.login1.Manager",
+                                             "ActivateSessionOnSeat",
+                                             g_variant_new ("(ss)", session_id, seat_id),
+                                             NULL, /* expected reply */
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             &error);
+        if (reply == NULL) {
+                g_debug ("GdmManager: logind 'ActivateSessionOnSeat' %s raised:\n %s\n\n",
+                         g_dbus_error_get_remote_error (error), error->message);
+                g_error_free (error);
+                return FALSE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+static gboolean
+activate_session_id_for_ck (GdmManager *manager,
+                            const char *seat_id,
+                            const char *session_id)
+{      
+        GError *error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (manager->connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             "org.freedesktop.ConsoleKit.Seat",
+                                             "ActivateSession",
+                                             g_variant_new ("(o)", session_id),
+                                             NULL, /* expected reply */
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             &error);
+        if (reply == NULL) {
+                g_debug ("GdmManager: ConsoleKit %s raised:\n %s\n\n",
+                         g_dbus_error_get_remote_error (error), error->message);
+                g_error_free (error);
+
+                /* It is very likely that the "error" just reported is
+                 * that the session is already active.  Unfortunately,
+                 * ConsoleKit doesn't use proper error codes and it
+                 * translates the error message, so we have no real way
+                 * to detect this case...
+                 */
+                return TRUE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+#endif
+
+static gboolean
+activate_session_id (GdmManager *manager,
+                     const char *seat_id,
+                     const char *session_id)
+{
+
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return activate_session_id_for_systemd (manager, seat_id, session_id);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return activate_session_id_for_ck (manager, seat_id, session_id);
+#else
+        return FALSE;
+#endif
+}
+
+#ifdef WITH_SYSTEMD
+static gboolean
+session_unlock_for_systemd (GdmManager *manager,
                 const char *ssid)
 {
         GError *error = NULL;
@@ -329,7 +598,60 @@
 
         return TRUE;
 }
+#endif
 
+#ifdef WITH_CONSOLE_KIT
+static gboolean
+session_unlock_for_ck (GdmManager *manager,
+                       const char *ssid)
+{
+        GError *error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (manager->connection,
+                                             CK_NAME,
+                                             ssid,
+                                             CK_SESSION_INTERFACE,
+                                             "Unlock",
+                                             NULL, /* parameters */
+                                             NULL, /* expected reply */
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             &error);
+        if (reply == NULL) {
+                g_debug ("GdmManager: ConsoleKit %s raised:\n %s\n\n",
+                         g_dbus_error_get_remote_error (error), error->message);
+                g_error_free (error);
+                return FALSE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+#endif
+
+static gboolean
+session_unlock (GdmManager *manager,
+                const char *ssid)
+{
+
+        g_debug ("Unlocking session %s", ssid);
+
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return session_unlock_for_systemd (manager, ssid);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return session_unlock_for_ck (manager, ssid);
+#else
+        return TRUE;
+#endif
+}
+
 static GdmSession *
 find_session_for_user_on_seat (GdmManager *manager,
                                const char *username,
@@ -377,8 +699,9 @@
         return NULL;
 }
 
+#ifdef WITH_SYSTEMD
 static gboolean
-is_remote_session (GdmManager  *self,
+is_systemd_remote_session (GdmManager  *self,
                    const char  *session_id,
                    GError     **error)
 {
@@ -406,9 +729,62 @@
 
         return is_remote;
 }
+#endif
 
+#ifdef WITH_CONSOLE_KIT
+static gboolean
+is_consolekit_remote_session (GdmManager       *self,
+                             GDBusConnection  *connection,
+                             const char       *session_id,
+                             GError          **error)
+{
+        GVariant *reply;
+        gboolean is_remote;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "IsLocal",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(b)"),
+                                            G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+               return FALSE;
+        }
+
+        g_variant_get (reply, "(b)", &is_remote);
+        g_variant_unref (reply);
+
+        return is_remote;
+}
+#endif
+
+static gboolean
+is_remote_session (GdmManager       *self,
+                  GDBusConnection  *connection,
+                  const char       *session_id,
+                  GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return is_systemd_remote_session (self, session_id, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return is_consolekit_remote_session (self, connection, session_id, error);
+#endif
+
+        return FALSE;
+}
+
+#ifdef WITH_SYSTEMD
 static char *
-get_seat_id_for_session_id (const char  *session_id,
+get_seat_id_for_systemd_session_id (const char  *session_id,
                             GError     **error)
 {
         int ret;
@@ -434,9 +810,57 @@
 
         return out_seat;
 }
+#endif
 
+#ifdef WITH_CONSOLE_KIT
 static char *
-get_tty_for_session_id (const char  *session_id,
+get_seat_id_for_consolekit_session_id (GDBusConnection  *connection,
+                                       const char       *session_id,
+                                       GError          **error)
+{
+        GVariant *reply;
+        char *retval;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetSeatId",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return NULL;
+        }
+
+        g_variant_get (reply, "(o)", &retval);
+        g_variant_unref (reply);
+
+        return retval;
+}
+#endif
+
+static char *
+get_seat_id_for_session_id (GDBusConnection  *connection,
+                            const char       *session_id,
+                            GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_seat_id_for_systemd_session_id (session_id, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return get_seat_id_for_consolekit_session_id (connection, session_id, error);
+#endif
+return NULL;}
+#ifdef WITH_SYSTEMD
+static char *
+get_tty_for_systemd_session_id (const char  *session_id,
                         GError     **error)
 {
         int ret;
@@ -461,7 +885,22 @@
 
         return out_tty;
 }
+#endif
 
+static char *
+get_tty_for_session_id (const char  *session_id,
+                        GError     **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_tty_for_systemd_session_id (session_id, error);
+        }
+#endif
+
+        return NULL;
+}
+
+
 static void
 get_display_and_details_for_bus_sender (GdmManager       *self,
                                         GDBusConnection  *connection,
@@ -504,11 +943,10 @@
                 goto out;
         }
 
-        ret = gdm_find_display_session (pid, caller_uid, &session_id, &error);
+        session_id = get_session_id_for_pid (connection, pid, &error);
 
-        if (!ret) {
-                g_debug ("GdmManager: Unable to find display session for uid %d: %s",
-                         (int) caller_uid,
+        if (session_id == NULL) {
+                g_debug ("GdmManager: Error while retrieving session id for sender: %s",
                          error->message);
                 g_error_free (error);
                 goto out;
@@ -519,7 +957,7 @@
         }
 
         if (out_is_login_screen != NULL) {
-                *out_is_login_screen = is_login_session (self, session_id, &error);
+                *out_is_login_screen = is_login_session (self, connection, session_id, &error);
 
                 if (error != NULL) {
                         g_debug ("GdmManager: Error while checking if sender is login screen: %s",
@@ -529,7 +967,7 @@
                 }
         }
 
-        if (!get_uid_for_session_id (session_id, &session_uid, &error)) {
+        if (!get_uid_for_session_id (connection, session_id, &session_uid, &error)) {
                 g_debug ("GdmManager: Error while retrieving uid for session: %s",
                          error->message);
                 g_error_free (error);
@@ -546,7 +984,7 @@
         }
 
         if (out_seat_id != NULL) {
-                *out_seat_id = get_seat_id_for_session_id (session_id, &error);
+                *out_seat_id = get_seat_id_for_session_id (connection, session_id, &error);
 
                 if (error != NULL) {
                         g_debug ("GdmManager: Error while retrieving seat id for session: %s",
@@ -556,7 +994,7 @@
         }
 
         if (out_is_remote != NULL) {
-                *out_is_remote = is_remote_session (self, session_id, &error);
+                *out_is_remote = is_remote_session (self, connection, session_id, &error);
 
                 if (error != NULL) {
                         g_debug ("GdmManager: Error while retrieving remoteness for session: %s",
@@ -613,7 +1051,7 @@
         if (existing_session != NULL) {
                 ssid_to_activate = gdm_session_get_session_id (existing_session);
                 if (seat_id != NULL) {
-                        res = gdm_activate_session_by_id (manager->connection, NULL, seat_id, ssid_to_activate);
+                        res = activate_session_id (manager, seat_id, ssid_to_activate);
                         if (! res) {
                                 g_debug ("GdmManager: unable to activate session: %s", ssid_to_activate);
                                 goto out;
@@ -1032,7 +1470,7 @@
                  * same audit session, ignore it since it doesn't "own" the
                  * reauthentication session
                  */
-                client_session_id = get_session_id_for_pid (pid_of_client,
+                client_session_id = get_session_id_for_pid (self->connection, pid_of_client,
                                                             NULL);
                 session_id = g_object_get_data (G_OBJECT (session), "caller-session-id");
 
@@ -1251,16 +1689,20 @@
 display_is_on_seat0 (GdmDisplay *display)
 {
         gboolean is_on_seat0 = TRUE;
-        char *seat_id = NULL;
 
-        g_object_get (G_OBJECT (display), "seat-id", &seat_id, NULL);
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                char *seat_id = NULL;
 
-        if (g_strcmp0 (seat_id, "seat0") != 0) {
-            is_on_seat0 = FALSE;
+                g_object_get (G_OBJECT (display), "seat-id", &seat_id, NULL);
+
+                if (g_strcmp0 (seat_id, "seat0") != 0) {
+                        is_on_seat0 = FALSE;
+                }
+                g_free (seat_id);
         }
+#endif
 
-        g_free (seat_id);
-
         return is_on_seat0;
 }
 
@@ -2059,12 +2501,58 @@
         remove_user_session (manager, session);
 }
 
+static char * 
+query_ck_for_display_device (GdmManager *manager,
+                             GdmDisplay *display) 
+{
+        char    *out;
+        char    *command;
+        char    *display_name = NULL;
+        int      status;
+        gboolean res;
+        GError  *error;
+                
+        g_object_get (G_OBJECT (display),
+                      "x11-display-name", &display_name,
+                      NULL);                                  
+        
+        error = NULL;
+        command = g_strdup_printf ("/usr/lib/ck-get-x11-display-device --display %s",   
+                                   display_name);
+        g_free (display_name);
+                 
+        g_debug ("GdmManager: Running helper %s", command);
+        out = NULL;
+        res = g_spawn_command_line_sync (command,
+                                         &out,
+                                         NULL,
+                                         &status,
+                                         &error);
+        if (! res) {
+                g_warning ("GdmManager: Could not run helper %s: %s", command, error->message);
+                g_error_free (error);
+        } else {
+                out = g_strstrip (out);
+                g_debug ("GdmManager: Got tty: '%s'", out);
+        }
+
+        g_free (command);
+
+        return out;
+}
+
 static char *
 get_display_device (GdmManager *manager,
                     GdmDisplay *display)
 {
-        /* systemd finds the display device out on its own based on the display */
-        return NULL;
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                /* systemd finds the display device out on its own based on the display */
+                return NULL;
+        }
+#endif
+
+        return query_ck_for_display_device (manager, display);
 }
 
 static void
@@ -2074,6 +2562,7 @@
 {
         gboolean fail_if_already_switched = FALSE;
 
+#ifdef WITH_SYSTEMD
         if (gdm_session_get_display_mode (session) == GDM_SESSION_DISPLAY_MODE_REUSE_VT) {
                 const char *seat_id;
                 char *session_id;
@@ -2092,6 +2581,7 @@
                         g_free (session_id);
                 }
         }
+#endif
 
         /* There should already be a session running, so jump to its
          * VT. In the event we're already on the right VT, (i.e. user
--- b/daemon/gdm-local-display-factory.c	2024-01-18 20:16:14.432301640 -0800
+++ a/daemon/gdm-local-display-factory.c	2024-01-18 20:12:21.357947062 -0800
@@ -32,7 +32,9 @@
 #include <gudev/gudev.h>
 #endif
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-login.h>
+#endif
 
 #include "gdm-common.h"
 #include "gdm-manager.h"
@@ -46,6 +48,8 @@
 #include "gdm-local-display.h"
 #include "gdm-legacy-display.h"
 
+#define CK_SEAT1_PATH                       "/org/freedesktop/ConsoleKit/Seat1"
+
 #define GDM_DBUS_PATH                       "/org/gnome/DisplayManager"
 #define GDM_LOCAL_DISPLAY_FACTORY_DBUS_PATH GDM_DBUS_PATH "/LocalDisplayFactory"
 #define GDM_MANAGER_DBUS_NAME               "org.gnome.DisplayManager.LocalDisplayFactory"
@@ -97,6 +101,11 @@
 static void     gdm_local_display_factory_init          (GdmLocalDisplayFactory      *factory);
 static void     gdm_local_display_factory_finalize      (GObject                     *object);
 
+static GdmDisplay *create_display                       (GdmLocalDisplayFactory      *factory,
+                                                         const char                  *seat_id,
+                                                         const char                  *session_type,
+                                                         gboolean                    initial_display);
+
 static void     ensure_display_for_seat                 (GdmLocalDisplayFactory      *factory,
                                                          const char                  *seat_id);
 
@@ -104,7 +113,9 @@
                                                          GParamSpec                  *arg1,
                                                          GdmLocalDisplayFactory      *factory);
 
+#ifdef WITH_SYSTEMD
 static gboolean gdm_local_display_factory_sync_seats    (GdmLocalDisplayFactory *factory);
+#endif
 static gpointer local_display_factory_object = NULL;
 static gboolean lookup_by_session_id (const char *id,
                                       GdmDisplay *display,
@@ -538,7 +549,9 @@
                       "session-id", &session_id,
                       NULL);
 
+#ifdef WITH_SYSTEMD
         sd_seat_get_active (seat_id, &seat_active_session, NULL);
+#endif
 
         status = gdm_display_get_status (display);
 
@@ -563,7 +576,7 @@
                         /* reset num failures */
                         factory->num_failures = 0;
 
-                        ensure_display_for_seat (factory, seat_id);
+                        create_display (factory, seat_id, session_type, is_initial);
                 }
                 break;
         case GDM_DISPLAY_FAILED:
@@ -580,7 +593,11 @@
                         if (factory->num_failures > MAX_DISPLAY_FAILURES)
                                 g_warning ("GdmLocalDisplayFactory: maximum number of X display failures reached: check X server log for errors");
                         else
+#ifdef WITH_SYSTEMD
                                 ensure_display_for_seat (factory, seat_id);
+#else
+                               create_display (factory, seat_id, session_type, is_initial);
+#endif
                 }
                 break;
         case GDM_DISPLAY_UNMANAGED:
@@ -643,6 +660,52 @@
         return lookup_by_seat_id (id, display, user_data);
 }
 
+static GdmDisplay *
+create_display (GdmLocalDisplayFactory *factory,
+                const char             *seat_id,
+                const char             *session_type,
+                gboolean                initial)
+{
+        GdmDisplayStore *store;
+        GdmDisplay      *display = NULL;
+
+        g_debug ("GdmLocalDisplayFactory: %s login display for seat %s requested",
+                 session_type? : "X11", seat_id);
+        store = gdm_display_factory_get_display_store (GDM_DISPLAY_FACTORY (factory));
+
+        display = gdm_display_store_find (store, lookup_by_seat_id, (gpointer) seat_id);
+
+        /* Ensure we don't create the same display more than once */
+        if (display != NULL) {
+                g_debug ("GdmLocalDisplayFactory: display already created");
+                return NULL;
+        }
+
+        g_debug ("GdmLocalDisplayFactory: Adding display on seat %s", seat_id);
+
+        if (display == NULL) {
+                guint32 num;
+
+                num = take_next_display_number (factory);
+
+                display = gdm_legacy_display_new (num);
+        }
+
+        g_object_set (display, "seat-id", seat_id, NULL);
+        g_object_set (display, "is-initial", initial, NULL);
+
+        store_display (factory, display);
+
+        /* let store own the ref */
+        g_object_unref (display);
+
+        if (! gdm_display_manage (display)) {
+                gdm_display_unmanage (display);
+        }
+
+        return display;
+}
+
 static gboolean
 lookup_managed_display_by_seat_id (const char *id,
                                    GdmDisplay *display,
@@ -800,6 +863,7 @@
 
         g_debug ("GdmLocalDisplayFactory: display for seat %s requested", seat_id);
 
+#ifdef WITH_SYSTEMD
         /* If we already have a login window, switch to it */
         if (gdm_get_login_window_session_id (seat_id, &login_session_id)) {
                 GdmDisplay *display;
@@ -819,6 +883,7 @@
                         return;
                 }
         }
+#endif  
 
         preferred_display_server = get_preferred_display_server (factory);
 
@@ -860,7 +925,11 @@ ensure_display_for_seat (GdmLocalDisplayFactory *factory,
         if (!waiting_on_udev) {
                 int ret;
 
+#ifdef WITH_SYSTEMD
                 ret = sd_seat_can_graphical (seat_id);
+#else
+                ret = 1;
+#endif
 
                 if (ret < 0) {
                         g_critical ("Failed to query CanGraphical information for seat %s", seat_id);
@@ -967,6 +1032,7 @@
         return;
 }
 
+#ifdef WITH_SYSTEMD
 static void
 delete_display (GdmLocalDisplayFactory *factory,
                 const char             *seat_id) {
@@ -1437,6 +1503,7 @@
         g_clear_handle_id (&factory->wait_to_finish_timeout_id, g_source_remove);
 #endif
 }
+#endif
 
 static void
 on_display_added (GdmDisplayStore        *display_store,
@@ -1471,6 +1538,7 @@
 {
         GdmLocalDisplayFactory *factory = GDM_LOCAL_DISPLAY_FACTORY (base_factory);
         GdmDisplayStore *store;
+	GdmDisplay *display;
 
         g_return_val_if_fail (GDM_IS_LOCAL_DISPLAY_FACTORY (factory), FALSE);
 
@@ -1490,8 +1558,18 @@
                                  factory,
                                  0);
 
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
         gdm_local_display_factory_start_monitor (factory);
         return gdm_local_display_factory_sync_seats (factory);
+        }
+#endif
+
+        /* On ConsoleKit just create Seat1, and that's it. */
+        display = create_display (factory, CK_SEAT1_PATH, NULL, TRUE);
+
+        return display != NULL;
+
 }
 
 static gboolean
@@ -1499,10 +1577,13 @@
 {
         GdmLocalDisplayFactory *factory = GDM_LOCAL_DISPLAY_FACTORY (base_factory);
         GdmDisplayStore *store;
+        GdmDisplay *display;
 
         g_return_val_if_fail (GDM_IS_LOCAL_DISPLAY_FACTORY (factory), FALSE);
 
+#ifdef WITH_SYSTEMD
         gdm_local_display_factory_stop_monitor (factory);
+#endif
 
         store = gdm_display_factory_get_display_store (GDM_DISPLAY_FACTORY (factory));
 
@@ -1656,7 +1737,9 @@
 
         g_hash_table_destroy (factory->used_display_numbers);
 
+#ifdef WITH_SYSTEMD
         gdm_local_display_factory_stop_monitor (factory);
+#endif
 
         G_OBJECT_CLASS (gdm_local_display_factory_parent_class)->finalize (object);
 }

--- a/daemon/gdm-session.c	2024-01-29 11:19:58.881365390 -0800
+++ b/daemon/gdm-session.c	2024-01-29 11:30:47.394669695 -0800
@@ -3014,8 +3014,7 @@
                                                            self->selected_program);
                         }
                 } else {
-                        program = g_strdup_printf ("dbus-run-session -- %s",
-                                                   self->selected_program);
+                        program = g_strdup_printf (self->selected_program);
                 }
         }
 
@@ -3414,7 +3413,7 @@
                  self->display_seat_id);
 
         if (g_strcmp0 (self->display_seat_id, "seat0") != 0) {
-                return GDM_SESSION_DISPLAY_MODE_LOGIND_MANAGED;
+                return GDM_SESSION_DISPLAY_MODE_REUSE_VT;
         }
 
 #ifdef ENABLE_USER_DISPLAY_SERVER
@@ -3465,6 +3464,27 @@
         self->selected_program = g_strdup (text);
 }
 
+void
+gdm_session_select_session_type (GdmSession *self,
+                                 const char *text)
+{
+        GHashTableIter iter;
+        gpointer key, value;
+
+        g_debug ("GdmSession: selecting session type '%s'", text);
+
+        g_hash_table_iter_init (&iter, self->conversations);
+        while (g_hash_table_iter_next (&iter, &key, &value)) {
+                GdmSessionConversation *conversation;
+
+               conversation = (GdmSessionConversation *) value;
+
+                gdm_dbus_worker_call_set_session_type (conversation->worker_proxy,
+                                                       text,
+                                                       NULL, NULL, NULL);
+        }
+}
+
 void
 gdm_session_select_session (GdmSession *self,
                             const char *text)
--- gdm-45.0.1/meson.build
+++ gdm-45.0.1/meson.build
@@ -233,6 +233,7 @@ conf.set('HAVE_UT_UT_TV', utmp_has_tv_fi
 conf.set('HAVE_UT_UT_SYSLEN', utmp_has_syslen_field)
 conf.set('ENABLE_IPV6', get_option('ipv6'))
 conf.set('HAVE_SYS_SOCKIO_H', cc.has_header('sys/sockio.h'))
+conf.set('WITH_CONSOLE_KIT', '1')
 configure_file(output: 'config.h', configuration: conf)
 
 # Subdirs
