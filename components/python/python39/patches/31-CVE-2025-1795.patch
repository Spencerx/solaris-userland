Fixes CVE-2025-1795.

Desc:
  During an address list folding when a separating comma ends up on a folded
  line and that line is to be unicode-encoded then the separator itself is
  also unicode-encoded. Expected behavior is that the separating comma
  remains a plan comma. This can result in the address header being
  misinterpreted by some mail servers.

Backported from upstream:
https://github.com/python/cpython/pull/115593
https://github.com/python/cpython/pull/119393
and minor changes from:
https://github.com/python/cpython/pull/129009

--- Python-3.9.23/Lib/email/_header_value_parser.py
+++ Python-3.9.23/Lib/email/_header_value_parser.py
@@ -959,6 +959,8 @@ class _InvalidEwError(errors.HeaderParse
 # up other parse trees.  Maybe should have  tests for that, too.
 DOT = ValueTerminal('.', 'dot')
 ListSeparator = ValueTerminal(',', 'list-separator')
+ListSeparator.as_ew_allowed = False
+ListSeparator.syntactic_break = False
 RouteComponentMarker = ValueTerminal('@', 'route-component-marker')
 
 #
@@ -2032,7 +2034,7 @@ def get_address_list(value):
             address_list.defects.append(errors.InvalidHeaderDefect(
                 "invalid address in address-list"))
         if value:  # Must be a , at this point.
-            address_list.append(ValueTerminal(',', 'list-separator'))
+            address_list.append(ListSeparator)
             value = value[1:]
     return address_list, value
 
@@ -2833,13 +2835,22 @@ def _refold_parse_tree(parse_tree, *, po
             if not hasattr(part, 'encode'):
                 # It's not a Terminal, do each piece individually.
                 parts = list(part) + parts
-            else:
+                want_encoding = False
+                continue
+            elif part.as_ew_allowed:
                 # It's a terminal, wrap it as an encoded word, possibly
                 # combining it with previously encoded words if allowed.
                 last_ew = _fold_as_ew(tstr, lines, maxlen, last_ew,
                                       part.ew_combine_allowed, charset)
-            want_encoding = False
-            continue
+                want_encoding = False
+                continue
+            else:
+                # It's a terminal which should be kept non-encoded
+                # (e.g. a ListSeparator).
+                last_ew = None
+                want_encoding = False
+                # fall through
+
         if len(tstr) <= maxlen - len(lines[-1]):
             lines[-1] += tstr
             continue
--- Python-3.9.23/Lib/test/test_email/test__header_value_parser.py
+++ Python-3.9.23/Lib/test/test_email/test__header_value_parser.py
@@ -2973,6 +2973,19 @@ class TestFolding(TestEmailBase):
             with self.subTest(to=to):
                 self._test(parser.get_address_list(to)[0], folded, policy=policy)
 
+    def test_address_list_with_list_separator_after_fold(self):
+        a = 'x' * 66 + '@example.com'
+        to = f'{a}, "Hübsch Kaktus" <beautiful@example.com>'
+        self._test(parser.get_address_list(to)[0],
+            f'{a},\n =?utf-8?q?H=C3=BCbsch?= Kaktus <beautiful@example.com>\n')
+
+        a = '.' * 79  # ('.' is a special, so must be in quoted-string.)
+        to = f'"{a}" <xyz@example.com>, "Hübsch Kaktus" <beautiful@example.com>'
+        self._test(parser.get_address_list(to)[0],
+            f'"{a}"\n'
+            ' <xyz@example.com>, =?utf-8?q?H=C3=BCbsch?= Kaktus '
+            '<beautiful@example.com>\n')
+
     def test_address_list_with_specials_in_encoded_word(self):
         # An encoded-word parsed from a structured header must remain
         # encoded when it contains specials. Regression for gh-121284.
