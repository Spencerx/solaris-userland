Debian patch adjusted for Solaris bundled Unzip 610c25.
Therefore uses izu_malloc/izu_free instead of malloc/free.

From: Steven M. Schweda <sms@antinode.info>
Subject: Fix for CVE-2022-0529 and CVE-2022-0530
Bug-Debian: https://bugs.debian.org/1010355
X-Debian-version: 6.0-27

--- unzip610c25/fileio.c
+++ unzip610c25/fileio.c
@@ -190,8 +190,10 @@ static ZCONST char Far FilenameTooLongTr
   "warning:  filename too long--truncating.\n";
 
 #ifdef UNICODE_SUPPORT
+static ZCONST char Far UFilenameCorrupt[] =
+ "error: Unicode filename corrupt.\n";
 static ZCONST char Far UFilenameTooLongTrunc[] =
- "warning:  Converted unicode filename too long--truncating.\n";
+ "warning:  Converted Unicode filename too long--truncating.\n";
 #endif /* def UNICODE_SUPPORT */
 
 static ZCONST char Far ExtraFieldCorrupt[] =
@@ -3413,16 +3415,30 @@ char *fn;
                   /* convert UTF-8 to local character set */
                   fn = utf8_to_local_string(G.unipath_filename,
                                             G.unicode_escape_all);
-                  /* make sure filename is short enough */
-                  if (strlen(fn) >= FILNAMSIZ) {
-                    fn[FILNAMSIZ - 1] = '\0';
+
+                  /* 2022-07-22 SMS, et al.  CVE-2022-0530
+                   * Detect conversion failure, emit message.
+                   * Continue with unconverted name.
+                   */
+                  if (fn == NULL)
+                  {
                     Info(slide, 0x401, ((char *)slide,
-                      LoadFarString(UFilenameTooLongTrunc)));
-                    error = PK_WARN;
+                     LoadFarString(UFilenameCorrupt)));
+                    error = PK_ERR;
+                  }
+                  else
+                  {
+                    /* make sure filename is short enough */
+                    if (strlen(fn) >= FILNAMSIZ) {
+                      fn[FILNAMSIZ - 1] = '\0';
+                      Info(slide, 0x401, ((char *)slide,
+                        LoadFarString(UFilenameTooLongTrunc)));
+                      error = PK_WARN;
+                    }
+                    /* replace filename with converted UTF-8 */
+                    strcpy(G.filename, fn);
+                    izu_free(fn);
                   }
-                  /* replace filename with converted UTF-8 */
-                  strcpy(G.filename, fn);
-                  izu_free(fn);
                 }
 # endif /* def UNICODE_WCHAR */
 
--- unzip610c25/process.c
+++ unzip610c25/process.c
@@ -239,6 +239,8 @@ static ZCONST char Far UnicodeVersionErr
      "warning:  Unicode Path version > 1\n";
    static ZCONST char Far UnicodeMismatchError[] =
      "warning:  Unicode Path checksum invalid\n";
+   static ZCONST char Far UFilenameTooLongTrunc[] =
+     "warning:  filename too long (P1) -- truncating.\n";
 #endif
 
 
@@ -2521,7 +2523,7 @@ }
 
         if (eb_id == EF_PKSZ64)
         {
-          int offset = EB_HEADSIZE;
+          unsigned offset = EB_HEADSIZE;
 
           if ((G.crec.ucsize == Z64FLGL) || (G.lrec.ucsize == Z64FLGL))
           {
@@ -2623,7 +2625,7 @@ break;
         }
         if (eb_id == EF_UNIPATH) {
 
-          int offset = EB_HEADSIZE;
+          unsigned offset = EB_HEADSIZE;
           ush ULen = (ush)(eb_len - 5);
           ulg chksum = CRCVAL_INITIAL;
 
@@ -3079,9 +3081,10 @@ int b;
   int state_dependent;
   int wsize;
   int max_bytes = MB_CUR_MAX;
-  char buf[9];
+  char buf[ MB_CUR_MAX+ 1];             /* ("+1" not really needed?) */
   char *buffer = NULL;
   char *local_string = NULL;
+  size_t buffer_size;                   /* CVE-2022-0529 */
 
   if (wide_string == NULL)
     return NULL;
@@ -3091,7 +3094,8 @@ for (wsize = 0; wide_string[wsize]; wsiz
   if (max_bytes < MAX_ESCAPE_BYTES)
     max_bytes = MAX_ESCAPE_BYTES;
 
-  if ((buffer = (char *)izu_malloc(wsize * max_bytes + 1)) == NULL) {
+  buffer_size = wsize * max_bytes + 1;          /* Reused below. */
+  if ((buffer = (char *)izu_malloc( buffer_size)) == NULL) {
     return NULL;
   }
 
@@ -3129,8 +3133,28 @@ strncat(buffer, buf, b);
     } else {
       /* no MB for this wide */
         /* use escape for wide character */
-        char *escape_string = wide_to_escape_string(wide_string[i]);
-        strcat(buffer, escape_string);
+        size_t buffer_len;
+        size_t escape_string_len;
+        char *escape_string;
+        int err_msg = 0;
+
+        escape_string = wide_to_escape_string(wide_string[i]);
+        buffer_len = strlen( buffer);
+        escape_string_len = strlen( escape_string);
+
+        /* Append escape string, as space allows. */
+        /* 2022-07-18 SMS, et al.  CVE-2022-0529 */
+        if (escape_string_len > buffer_size- buffer_len- 1)
+        {
+            escape_string_len = buffer_size- buffer_len- 1;
+            if (err_msg == 0)
+            {
+                err_msg = 1;
+                Info(slide, 0x401, ((char *)slide,
+                 LoadFarString( UFilenameTooLongTrunc)));
+            }
+        }
+        strncat( buffer, escape_string, escape_string_len);
         izu_free(escape_string);
     }
   }
@@ -3183,9 +3207,18 @@ char *utf8_to_local_string(utf8_string,
   ZCONST char *utf8_string;
   int escape_all;
 {
-  zwchar *wide = utf8_to_wide_string(utf8_string);
-  char *loc = wide_to_local_string(wide, escape_all);
-  izu_free(wide);
+  zwchar *wide;
+  char *loc = NULL;
+
+  wide = utf8_to_wide_string( utf8_string);
+
+  /* 2022-07-25 SMS, et al.  CVE-2022-0530 */
+  if (wide != NULL)
+  {
+    loc = wide_to_local_string( wide, escape_all);
+    izu_free( wide);
+  }
+
   return loc;
 }
 
