Debian/madler patch adjusted for Solaris bundled Unzip 610c25.

extract.c:
- find_local_header() is only available in unzip610c25 code base. And since it defines 'request' variable
  which is now needed in calling function extract_or_test_entrylist() it needs to be defined there and pointer
  to it is passed into find_local_header(). Therefore uses of  'request' in find_local_header() need to be changed
  to pointer.
  Note that extract_or_test_entrylistw() (note 'w' at the end of name) also calls find_local_header() but is only
  used on Windows.
- unzip610c25 code base has different order of functions and thus patch chunks are also in different order.

From: Mark Adler <madler@alumni.caltech.edu>
Subject: Detect and reject a zip bomb using overlapped entries.
Origin: https://github.com/madler/unzip/commit/47b3ceae397d21bf822bc2ac73052a4b1daf8e1c
Bug-Debian: https://bugs.debian.org/931433
X-Debian-version: 6.0-24

    Detect and reject a zip bomb using overlapped entries.
    
    This detects an invalid zip file that has at least one entry that
    overlaps with another entry or with the central directory to the
    end of the file. A Fifield zip bomb uses overlapped local entries
    to vastly increase the potential inflation ratio. Such an invalid
    zip file is rejected.
    
    See https://www.bamsoftware.com/hacks/zipbomb/ for David Fifield's
    analysis, construction, and examples of such zip bombs.
    
    The detection maintains a list of covered spans of the zip files
    so far, where the central directory to the end of the file and any
    bytes preceding the first entry at zip file offset zero are
    considered covered initially. Then as each entry is decompressed
    or tested, it is considered covered. When a new entry is about to
    be processed, its initial offset is checked to see if it is
    contained by a covered span. If so, the zip file is rejected as
    invalid.
    
    This commit depends on a preceding commit: "Fix bug in
    undefer_input() that misplaced the input state."

--- unzip610c25/extract.c
+++ unzip610c25/extract.c
@@ -404,6 +404,125 @@ "\n     PPMd: flags = 0x%04x.  Order = %
 /* Inconsistent Java "CAFE" extra fields (local v. central dir.). */
 static ZCONST char Far InfoInconsistentJavaCAFE[] =
      "Inconsistent cantral-local Java CAFE.  Expect name warnings/problems.\n";
+static ZCONST char Far NotEnoughMemCover[] =
+  "error: not enough memory for bomb detection\n";
+static ZCONST char Far OverlappedComponents[] =
+  "error: invalid zip file with overlapped components (possible zip bomb)\n";
+
+
+
+
+
+/* A growable list of spans. */
+typedef zoff_t bound_t;
+typedef struct {
+    bound_t beg;        /* start of the span */
+    bound_t end;        /* one past the end of the span */
+} span_t;
+typedef struct {
+    span_t *span;       /* allocated, distinct, and sorted list of spans */
+    size_t num;         /* number of spans in the list */
+    size_t max;         /* allocated number of spans (num <= max) */
+} cover_t;
+
+/*
+ * Return the index of the first span in cover whose beg is greater than val.
+ * If there is no such span, then cover->num is returned.
+ */
+static size_t cover_find(cover, val)
+    cover_t *cover;
+    bound_t val;
+{
+    size_t lo = 0, hi = cover->num;
+    while (lo < hi) {
+        size_t mid = (lo + hi) >> 1;
+        if (val < cover->span[mid].beg)
+            hi = mid;
+        else
+            lo = mid + 1;
+    }
+    return hi;
+}
+
+/* Return true if val lies within any one of the spans in cover. */
+static int cover_within(cover, val)
+    cover_t *cover;
+    bound_t val;
+{
+    size_t pos = cover_find(cover, val);
+    return pos > 0 && val < cover->span[pos - 1].end;
+}
+
+/*
+ * Add a new span to the list, but only if the new span does not overlap any
+ * spans already in the list. The new span covers the values beg..end-1. beg
+ * must be less than end.
+ *
+ * Keep the list sorted and merge adjacent spans. Grow the allocated space for
+ * the list as needed. On success, 0 is returned. If the new span overlaps any
+ * existing spans, then 1 is returned and the new span is not added to the
+ * list. If the new span is invalid because beg is greater than or equal to
+ * end, then -1 is returned. If the list needs to be grown but the memory
+ * allocation fails, then -2 is returned.
+ */
+static int cover_add(cover, beg, end)
+    cover_t *cover;
+    bound_t beg;
+    bound_t end;
+{
+    size_t pos;
+    int prec, foll;
+
+    if (beg >= end)
+    /* The new span is invalid. */
+        return -1;
+
+    /* Find where the new span should go, and make sure that it does not
+       overlap with any existing spans. */
+    pos = cover_find(cover, beg);
+    if ((pos > 0 && beg < cover->span[pos - 1].end) ||
+        (pos < cover->num && end > cover->span[pos].beg))
+        return 1;
+
+    /* Check for adjacencies. */
+    prec = pos > 0 && beg == cover->span[pos - 1].end;
+    foll = pos < cover->num && end == cover->span[pos].beg;
+    if (prec && foll) {
+        /* The new span connects the preceding and following spans. Merge the
+           following span into the preceding span, and delete the following
+           span. */
+        cover->span[pos - 1].end = cover->span[pos].end;
+        cover->num--;
+        memmove(cover->span + pos, cover->span + pos + 1,
+                (cover->num - pos) * sizeof(span_t));
+    }
+    else if (prec)
+        /* The new span is adjacent only to the preceding span. Extend the end
+           of the preceding span. */
+        cover->span[pos - 1].end = end;
+    else if (foll)
+        /* The new span is adjacent only to the following span. Extend the
+           beginning of the following span. */
+        cover->span[pos].beg = beg;
+    else {
+        /* The new span has gaps between both the preceding and the following
+           spans. Assure that there is room and insert the span.  */
+        if (cover->num == cover->max) {
+            size_t max = cover->max == 0 ? 16 : cover->max << 1;
+            span_t *span = realloc(cover->span, max * sizeof(span_t));
+            if (span == NULL)
+                return -2;
+            cover->span = span;
+            cover->max = max;
+        }
+        memmove(cover->span + pos + 1, cover->span + pos,
+                (cover->num - pos) * sizeof(span_t));
+        cover->num++;
+        cover->span[pos].beg = beg;
+        cover->span[pos].end = end;
+    }
+    return 0;
+}
 
 
 
@@ -2979,6 +3098,34 @@ undefer_input(__G);         /* Re-adjust
 #ifdef ENABLE_USER_PROGRESS
     G.action_msg_str = NULL;            /* Clear the progress mthd str. */
 #endif /* def ENABLE_USER_PROGRESS */
+
+    if ((G.lrec.general_purpose_bit_flag & 8) != 0) {
+        /* skip over data descriptor (harder than it sounds, due to signature
+         * ambiguity)
+         */
+#       define SIG 0x08074b50
+#       define LOW 0xffffffff
+        uch buf[12];
+        unsigned shy = 12 - readbuf((char *)buf, 12);
+        ulg crc = shy ? 0 : makelong(buf);
+        ulg clen = shy ? 0 : makelong(buf + 4);
+        ulg ulen = shy ? 0 : makelong(buf + 8); /* or high clen if ZIP64 */
+        if (crc == SIG &&                       /* if not SIG, no signature */
+            (G.lrec.crc32 != SIG ||             /* if not SIG, have signature */
+             (clen == SIG &&                    /* if not SIG, no signature */
+              ((G.lrec.csize & LOW) != SIG ||   /* if not SIG, have signature */
+               (ulen == SIG &&                  /* if not SIG, no signature */
+                (G.zip64 ? G.lrec.csize >> 32 : G.lrec.ucsize) != SIG
+                                                /* if not SIG, have signature */
+                )))))
+                   /* skip four more bytes to account for signature */
+                   shy += 4 - readbuf((char *)buf, 4);
+        if (G.zip64)
+            shy += 8 - readbuf((char *)buf, 8); /* skip eight more for ZIP64 */
+        if (shy)
+            error = PK_ERR;
+    }
+
     return error;
 
 } /* extract_or_test_member(). */
@@ -4521,15 +4668,15 @@ /**********************************/
 /*  Function find_local_header()  */
 /**********************************/
 
-static int find_local_header( __G__ perr_in_arch, filnum, pold_extra_bytes)
+static int find_local_header( __G__ perr_in_arch, filnum, pold_extra_bytes, request)
     __GDEF
     int *perr_in_arch;
     ulg filnum;
     zoff_t *pold_extra_bytes;
+    zoff_t *request;
 {
   zoff_t bufstart;
   zoff_t inbuf_offset;
-  zoff_t request;
   int error = PK_OK;                    /* Return PK-type error code. */
 
   /* If the target position is not within the current input buffer
@@ -4574,11 +4721,11 @@ /* TODO: check better too -- Is G.extra_
      * segmented?  Otherwise bigger harakiri is here
      * needed (here = whole request block below)
      */
-    request = G.pInfo->offset;
+    *request = G.pInfo->offset;
   }
   else
   {
-    request = G.pInfo->offset + G.extra_bytes;
+    *request = G.pInfo->offset + G.extra_bytes;
   }
 
   /* seek_zipf(__G__ pInfo->offset);  */
@@ -4586,15 +4733,20 @@ /* TODO: this code must be checked / ver
    * I'm not sure about impact of changes what are here done for
    * multi-disk support.
    */
-  inbuf_offset = request % INBUFSIZ;
-  bufstart = request - inbuf_offset;
+  if (cover_within((cover_t *)G.cover, *request)) {
+    Info(slide, 0x401, ((char *)slide,
+      LoadFarString(OverlappedComponents)));
+    return PK_BOMB;
+  }
+  inbuf_offset = *request % INBUFSIZ;
+  bufstart = *request - inbuf_offset;
 
   Trace((stderr, "\ndebug: request = %ld, inbuf_offset = %ld\n",
-   (long)request, (long)inbuf_offset));
+   (long)*request, (long)inbuf_offset));
   Trace((stderr,
    "debug: bufstart = %ld, cur_zipfile_bufstart = %ld\n",
    (long)bufstart, (long)G.cur_zipfile_bufstart));
-  if (request < 0)
+  if (*request < 0)
   {
     Info(slide, 0x401, ((char *)slide, LoadFarStringSmall(SeekMsg),
      G.zipfn, 1, LoadFarString(ReportMsg)));
@@ -4606,15 +4758,15 @@ LoadFarString(AttemptRecompensate)));
       /* Try a different "request". */
       *pold_extra_bytes = G.extra_bytes;
       G.extra_bytes = 0L;
-      request = G.pInfo->offset;  /* could also check if != 0 */
-      inbuf_offset = request % INBUFSIZ;
-      bufstart = request - inbuf_offset;
+      *request = G.pInfo->offset;  /* could also check if != 0 */
+      inbuf_offset = *request % INBUFSIZ;
+      bufstart = *request - inbuf_offset;
       Trace((stderr, "debug: request = %ld, inbuf_offset = %ld\n",
-       (long)request, (long)inbuf_offset));
+       (long)*request, (long)inbuf_offset));
       Trace((stderr,
        "debug: bufstart = %ld, cur_zipfile_bufstart = %ld\n",
        (long)bufstart, (long)G.cur_zipfile_bufstart));
-      if (request < 0)
+      if (*request < 0)
       {
         Trace((stderr,
          "debug: recompensated request still < 0\n"));
@@ -4683,7 +4835,7 @@ if (memcmp(G.sig, local_hdr_sig, 4))
     {
       /* Not the expected signature (1). */
       Info(slide, 0x401, ((char *)slide, LoadFarString(OffsetMsg),
-       filnum, LoadFarStringSmall(LocalHdrSig), (long)request));
+       filnum, LoadFarStringSmall(LocalHdrSig), (long)*request));
 #if DIAGNOSTIC
       GRRDUMP(G.sig, 4)
       GRRDUMP(local_hdr_sig, 4)
@@ -4711,7 +4863,7 @@ /* Signature seek/read (2) failed.  (Bad
           if (error != PK_BADERR)       /* (seek_zipf() status.) */
           {
             Info(slide, 0x401, ((char *)slide,
-             LoadFarString(OffsetMsg), filnum, "EOF", (long)request));
+             LoadFarString(OffsetMsg), filnum, "EOF", (long)*request));
           }
           error = *perr_in_arch = PK_BADERR;    /* Error.  Skip this member. */
         }
@@ -4722,7 +4874,7 @@ {
             /* Not the expected signature (2). */
             Info(slide, 0x401, ((char *)slide,
              LoadFarString(OffsetMsg), filnum,
-             LoadFarStringSmall(LocalHdrSig), (long)request));
+             LoadFarStringSmall(LocalHdrSig), (long)*request));
             *perr_in_arch = PK_BADERR;
             error = *perr_in_arch = PK_BADERR;  /* Error.  Skip this member. */
           }
@@ -4802,6 +4954,7 @@ int error_in_archive;
 {
     unsigned i;
     int renamed;
+    zoff_t request;
     int error;
 
 #ifdef IZ_CRYPT_AES_WG
@@ -4827,7 +4980,11 @@ /* Find the local header for this member
         error = find_local_header( __G__
                                    &error_in_archive,
                                    *pfilnum,
-                                   pold_extra_bytes);
+                                   pold_extra_bytes,
+                                   &request);
+
+        if (error == PK_BOMB)
+            return error;
 
         if (error != PK_OK)
             continue;           /* Find header failed.  Skip this member. */
@@ -5137,6 +5294,18 @@ close_segment( __G);
           return IZ_CTRLC;          /* Cancel operation by user request. */
         }
 #endif
+        error = cover_add((cover_t *)G.cover, request,
+                          G.cur_zipfile_bufstart + (G.inptr - G.inbuf));
+        if (error < 0) {
+            Info(slide, 0x401, ((char *)slide,
+              LoadFarString(NotEnoughMemCover)));
+            return PK_MEM;
+        }
+        if (error != 0) {
+            Info(slide, 0x401, ((char *)slide,
+              LoadFarString(OverlappedComponents)));
+            return PK_BOMB;
+        }
 #ifdef MACOS  /* MacOS is no preemptive OS, thus call event-handling by hand */
         UserStop();
 #endif
@@ -5173,6 +5342,7 @@ int error_in_archive;
 {
     unsigned i;
     int renamed;
+    zoff_t request;
     int error;
 
 # ifdef IZ_CRYPT_AES_WG
@@ -5194,7 +5364,11 @@ /* Find the local header for this member
         error = find_local_header( __G__
                                    &error_in_archive,
                                    *pfilnum,
-                                   pold_extra_bytes);
+                                   pold_extra_bytes,
+                                   &request);
+
+        if (error == PK_BOMB)
+            return error;
 
         if (error != PK_OK)
             continue;           /* Find header failed.  Skip this member. */
@@ -5527,6 +5701,29 @@ if (error != PK_OK)
         return error;
 #endif /* !defined(SFX) || defined(SFX_EXDIR) */
 
+    /* One more: initialize cover structure for bomb detection. Start with a
+       span that covers the central directory though the end of the file. */
+    if (G.cover == NULL) {
+        G.cover = malloc(sizeof(cover_t));
+        if (G.cover == NULL) {
+            Info(slide, 0x401, ((char *)slide,
+              LoadFarString(NotEnoughMemCover)));
+            return PK_MEM;
+        }
+        ((cover_t *)G.cover)->span = NULL;
+        ((cover_t *)G.cover)->max = 0;
+    }
+    ((cover_t *)G.cover)->num = 0;
+    if ((G.extra_bytes != 0 &&
+         cover_add((cover_t *)G.cover, 0, G.extra_bytes) != 0) ||
+        cover_add((cover_t *)G.cover,
+                  G.extra_bytes + G.ecrec.offset_start_central_directory,
+                  G.ziplen) != 0) {
+        Info(slide, 0x401, ((char *)slide,
+          LoadFarString(NotEnoughMemCover)));
+        return PK_MEM;
+    }
+
 /*---------------------------------------------------------------------------
     The basic idea of this function is as follows.  Since the central di-
     rectory lies at the end of the zipfile and the member files lie at the
@@ -5792,7 +5989,8 @@ if (error != PK_COOL) {
             if (error > error_in_archive)
                 error_in_archive = error;
             /* ...and keep going (unless disk full or user break) */
-            if (G.disk_full > 1 || error_in_archive == IZ_CTRLC) {
+            if (G.disk_full > 1 || error_in_archive == IZ_CTRLC ||
+                error == PK_BOMB) {
                 /* clear reached_end to signal premature stop ... */
                 reached_end = FALSE;
                 /* ... and cancel scanning the central directory */
--- unzip610c25/globals.c
+++ unzip610c25/globals.c
@@ -186,6 +186,7 @@ # if (!defined(NO_TIMESTAMPS))
     uO.D_flag = 1;  /* Default to '-D', no restoration of dir timestamps. */
 # endif
 # ifdef VMS
+    G.cover = NULL;     /* not allocated yet */
     G.echo_orig = -1;   /* Original terminal echo state (-1: unknown). */
 # endif
 
--- unzip610c25/globals.h
+++ unzip610c25/globals.h
@@ -313,12 +313,15 @@ cdir_file_hdr   crec;          /* used i
     ecdir_rec       ecrec;         /* used in unzip.c, extract.c */
     z_stat   statbuf;              /* used by main, mapname, check_for_newer */
 
+    int zip64;                     /* true if Zip64 info in extra field */
+
     int      mem_mode;
     uch      *outbufptr;           /* extract.c static */
     ulg      outsize;              /* extract.c static */
     int      reported_backslash;   /* extract.c static */
     int      disk_full;
     int      newfile;
+    void     **cover;              /* used in extract.c for bomb detection */
 
     int      didCRlast;            /* fileio static */
     ulg      numlines;             /* fileio static: number of lines printed */
--- unzip610c25/process.c
+++ unzip610c25/process.c
@@ -1832,6 +1832,13 @@ G.apl_dbl_hdr_alloc = 0;
     }
 # endif /* defined( UNIX) && defined( __APPLE__) */
 
+    /* Free the cover span list and the cover structure. */
+    if (G.cover != NULL) {
+        free(*(G.cover));
+        free(G.cover);
+        G.cover = NULL;
+    }
+
 } /* free_G_buffers(). */
 
 #endif /* def REENTRANT */
@@ -2484,6 +2491,8 @@ */
 #define Z64FLGS 0xffff
 #define Z64FLGL 0xffffffff
 
+    G.zip64 = FALSE;
+
     if (ef_len == 0 || ef_buf == NULL)
         return PK_COOL;
 
@@ -2661,6 +2670,8 @@ strncpy(G.unipath_filename,
                     (ZCONST char *)(offset + ef_buf), ULen);
             G.unipath_filename[ULen] = '\0';
           }
+
+          G.zip64 = TRUE;
         }
 
         /* Skip this extra field block */
--- unzip610c25/unzip.h
+++ unzip610c25/unzip.h
@@ -699,6 +699,7 @@ # define PK_MEM5            8   /* insuf
 # define PK_NOZIP           9   /* zipfile not found */
 # define PK_PARAM          10   /* bad or illegal parameters specified */
 # define PK_FIND           11   /* no files found */
+# define PK_BOMB           12   /* likely zip bomb */
 # define PK_COMPERR        19   /* error in compilation options */
 # define PK_DISK           50   /* disk full */
 # define PK_EOF            51   /* unexpected EOF */
